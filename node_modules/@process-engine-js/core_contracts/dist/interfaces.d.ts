import { ExecutionContext } from './execution_context';
export declare const EntityDiscoveryTag = "entityDiscoveryTag";
export declare const RouterDiscoveryTag = "routerDiscoveryTag";
export declare const ExtensionDiscoveryTag = "extensionDiscoveryTag";
export declare const TokenAdapterDiscoveryTag = "tokenAdapterDiscoveryTag";
export declare const FeatureGeneratorDiscoveryTag = "featureGeneratorDiscoveryTag";
export interface IApplicationService {
    id: string;
}
export interface ISessionStoreData {
    identityId: string;
    systemUserId: string;
    data?: any;
    roles: Array<string>;
}
export interface ITokenData {
    sessionId: string;
}
export declare enum TokenType {
    jwt = 0,
}
export interface IFactory<T> {
    (injectionArgs?: Array<any>, runtimeConfig?: any): T;
}
export interface IEntity {
    isNew: boolean;
    isDirty: boolean;
    id: string;
    initialize(derivedClassInstance: IEntity): Promise<void>;
    getProperty(propertyThisContext: any, propertyName: string): any;
    getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any>;
    setProperty(propertyThisContext: any, propertyName: string, value: any): void;
    getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any>;
    setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void>;
    toPojo(context: ExecutionContext, options?: IToPojoOptions): Promise<any>;
    fromPojo(context: ExecutionContext, data: any, options?: IFromPojoOptions): Promise<void>;
    save(context: ExecutionContext, options?: IPrivateSaveOptions): Promise<IEntity>;
    remove(context: ExecutionContext, options?: IPrivateRemoveOptions): Promise<void>;
    getEntityReference(): IEntityReference;
    calculate(context: ExecutionContext, options?: IPublicGetOptions): Promise<void>;
}
export interface IEntityReference {
    namespace: string;
    type: string;
    id: string;
    toPojo(): IPojoEntityReference;
}
export interface IPojoEntityReference {
    id: string;
    _meta: IPojoMetadata;
}
export interface IEntityCollectionReference {
    namespace: string;
    type: string;
    id: string;
    relatedType: string;
    relatedAttribute: string;
    toPojo(): any;
}
export interface IPojoMetadata {
    namespace: string;
    type: string;
    isRef: boolean;
    isNew: boolean;
}
export declare enum SaveMode {
    virtual = 0,
    persistance = 1,
    add = 2,
}
export interface IFromPojoOptions {
    mode?: SaveMode;
    select?: Array<string>;
    expandEntity?: Array<IExpand>;
    expandCollection?: Array<IExpand>;
}
export interface IToPojoOptions {
    hideInternals?: boolean;
    mode?: SaveMode;
    isNew?: boolean;
    saveFullEntity?: boolean;
    select?: Array<string>;
    skipCalculation?: boolean;
    _currentDepth?: number;
    maxDepth?: number;
}
export interface IPublicSaveOptions {
    expandEntity?: Array<IExpand>;
    reloadAfterSave?: boolean;
}
export interface IPrivateSaveOptions extends IPublicSaveOptions {
    isNew?: boolean;
    saveFullEntity?: boolean;
}
export interface IPublicGetOptions {
    select?: Array<string>;
    expandEntity?: Array<IExpand>;
    query?: IQueryObject | Array<IQueryObject> | string;
}
export interface IPrivateGetOptions extends IPublicGetOptions {
}
export declare enum QueryMethod {
    findOne = 0,
    count = 1,
    all = 2,
}
export interface IPublicQueryOptions {
    select?: Array<string>;
    query?: IQueryObject;
    orderBy?: ISortOptions;
    limit?: number;
    offset?: number;
    expandEntity?: Array<IExpand>;
    expandCollection?: Array<IExpand>;
}
export interface IPrivateQueryOptions extends IPublicQueryOptions {
    method?: QueryMethod;
    mode?: string;
    hideInternals?: boolean;
}
export interface IPublicRemoveOptions {
}
export interface IPrivateRemoveOptions extends IPublicRemoveOptions {
}
export declare enum LogicalOperatorType {
    and = 0,
    or = 1,
}
export interface IQueryObject {
}
export declare type CombinedQueryOperatorType = ('not' | 'and' | 'or');
export declare type ComparisonOperatorType = ('=' | '!=' | '>' | '<' | '>=' | '<=' | 'in' | 'notin' | 'beginswith' | 'contains' | 'endswith');
export interface IQueryClause extends IQueryObject {
    attribute: string;
    operator: ComparisonOperatorType;
    value: any;
    type?: string;
    ignoreCase?: boolean;
    escapeAttribute?: boolean;
    fnTemplate?: string;
}
export interface ICombinedQueryClause extends IQueryObject {
    operator: CombinedQueryOperatorType;
    queries: Array<IQueryObject>;
}
export interface IExpand {
    attribute: string;
    childAttributes?: Array<IExpand>;
}
export interface IGetSchemasOptions {
    excludeAbstract: boolean;
}
export interface IAllSchemas extends ISchemas {
}
export interface IInheritedSchema extends ISchema {
}
export interface ISchemas {
    [key: string]: {
        [namespace: string]: ISchema;
    };
}
export interface ISchema {
    name?: string;
    namespace?: string;
    entityKey?: string;
    attributes: ISchemaAttributes;
    expandEntity: Array<IExpand>;
    expandCollection: Array<IExpand>;
    indexes: IIndexes;
    isAbstract: boolean;
}
export interface ISchemaClass {
    expandEntity?: Array<IExpand>;
    expandCollection?: Array<IExpand>;
    indexes?: IIndexes;
    isAbstract?: boolean;
}
export interface ISchemaAttributes {
    [attributeName: string]: ISchemaAttribute;
}
export interface IIndexes {
    [indexName: string]: IIndex;
}
export interface IIndex {
    type: string;
    fields: Array<string>;
}
export declare enum SchemaAttributeType {
    string = 0,
    object = 1,
    number = 2,
    boolean = 3,
    int = 4,
    Date = 5,
    Blob = 6,
}
export interface ICalculatedPropertyOnQueryCallback {
    (context: ExecutionContext, query: IQueryClause): IQueryObject;
}
export interface ICalculatedPropertyOnSortCallback {
    (sortProperty: ISortProperty): ISortOptions;
}
export interface ICalculatedAttributeDeclaration {
    onQuery?: ICalculatedPropertyOnQueryCallback;
    onSort?: ICalculatedPropertyOnSortCallback;
    onGet?: Function;
    onSet?: Function;
}
export interface ISortOptions {
    attributes: Array<ISortProperty>;
}
export interface ISortProperty {
    attribute: string;
    order: SortOrder;
}
export declare type SortOrder = ('asc' | 'desc');
export interface ISchemaAttribute {
    type: SchemaAttributeType | string;
    isComplexType?: boolean;
    isEncrypted?: boolean;
    dbType?: string;
    internal?: boolean;
    calculated?: ICalculatedAttributeDeclaration;
    scope?: string;
    isPrimaryKey?: boolean;
    isInternal?: boolean;
    onInit?: Function;
    isList?: true;
    expandEntity?: Array<IExpand>;
    expandCollection?: Array<IExpand>;
    relatedAttribute?: string;
}
export declare const RegistrationKeySpacer = ":";
export declare const DefaultNamespace: any;
export interface INamingConventionService {
    getRegistrationKey(namespace: string, entityKey: string): string;
    parseRegistrationKey(registrationKey: string): IRegistrationKey;
    parseExpands(values: Array<string>): Array<IExpand>;
}
export interface IRegistrationKey {
    namespace: string;
    entityKey: string;
}
export interface IRequiredClaim {
    claim?: string;
    actions: Array<[ClaimActionType, Array<string>]>;
}
export declare enum ClaimActionType {
    create = 0,
    read = 1,
    write = 2,
    delete = 3,
    execute = 4,
    all = 5,
}
export interface IPromotionRoles {
    roles: Array<string>;
}
export interface IIamService {
    authenticateByUsername(username: string, password: string, tokenType?: TokenType): Promise<string>;
    authenticateBySystemUser(systemUser: string, tokenType?: TokenType): Promise<string>;
    createInternalContext(systemUser: string, tokenType?: TokenType): Promise<ExecutionContext>;
    resolveExecutionContext(encodedToken: string, tokenType?: TokenType): Promise<ExecutionContext>;
    hasClaim(context: ExecutionContext, claim: string): Promise<boolean>;
    getIdentity(context: ExecutionContext): Promise<IIdentity>;
    getIdentityEntity(context: ExecutionContext): Promise<IUserEntity>;
    logout(context: ExecutionContext): Promise<boolean>;
    initialize(): void;
    flattenRoles(roles: Array<string>): Array<string>;
    getGuest(): IIdentity;
}
export interface IUserEntity extends IEntity, IIdentity {
    name: string;
    password: string;
}
export interface IIdentity {
    id: string;
    name: string;
    roles: Array<string>;
}
export declare type HttpMethod = 'POST' | 'PUT' | 'DELETE' | 'GET';
