import {ExecutionContext} from './execution_context';

export const EntityDiscoveryTag = 'entityDiscoveryTag';
export const RouterDiscoveryTag = 'routerDiscoveryTag';
export const ExtensionDiscoveryTag = 'extensionDiscoveryTag';
export const TokenAdapterDiscoveryTag = 'tokenAdapterDiscoveryTag';
export const FeatureGeneratorDiscoveryTag = 'featureGeneratorDiscoveryTag'; 

export interface IApplicationService {
  id: string;
}

export interface ISessionStoreData {
  identityId: string;
  systemUserId: string;
  data?: any;
  roles: Array<string>;
}

export interface ITokenData {
  sessionId: string;
}

export enum TokenType {
  jwt
}

export interface IFactory<T> {
  (injectionArgs?: Array<any>, runtimeConfig?: any): T;
}

export interface IEntity {
  isNew: boolean;
  isDirty: boolean;
  id: string;
  initialize(derivedClassInstance: IEntity): Promise<void>;
  getProperty(propertyThisContext: any, propertyName: string): any;
  getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any>;
  setProperty(propertyThisContext: any, propertyName: string, value: any): void;
  getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any>;
  setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void>;
  toPojo(context: ExecutionContext, options?: IToPojoOptions): Promise<any>;
  fromPojo(context: ExecutionContext, data: any, options?: IFromPojoOptions): Promise<void>;
  save(context: ExecutionContext, options?: IPrivateSaveOptions): Promise<IEntity>;
  remove(context: ExecutionContext, options?: IPrivateRemoveOptions): Promise<void>;
  getEntityReference(): IEntityReference;
  calculate(context: ExecutionContext, options?: IPublicGetOptions): Promise<void>;

}

export interface IEntityReference {
  namespace: string;
  type: string;
  id: string;
  toPojo(): IPojoEntityReference;
}

export interface IPojoEntityReference {
  id: string;
  _meta: IPojoMetadata;
}

export interface IEntityCollectionReference {
  namespace: string;
  type: string;
  id: string;
  relatedType: string;
  relatedAttribute: string;
  toPojo(): any;
}

export interface IPojoMetadata {
  namespace: string;
  type: string;
  isRef: boolean;
  isNew: boolean;
}

export enum SaveMode {
  virtual, // bislang nicht verwendet, als default value? alternativ: undefined
  persistance,
  add
}

export interface IFromPojoOptions {
  mode?: SaveMode;
  select?: Array<string>;
  expandEntity?: Array<IExpand>;
  expandCollection?: Array<IExpand>;
}

export interface IToPojoOptions {
  hideInternals?: boolean;
  mode?: SaveMode;
  isNew?: boolean;
  saveFullEntity?: boolean;
  select?: Array<string>;
  skipCalculation?: boolean;
  _currentDepth?: number;
  maxDepth?: number;
}

export interface IPublicSaveOptions {
  expandEntity?: Array<IExpand>;
  reloadAfterSave?: boolean;
}

export interface IPrivateSaveOptions extends IPublicSaveOptions {
  isNew?: boolean;
  saveFullEntity?: boolean;
}

export interface IPublicGetOptions {
  select?: Array<string>;
  expandEntity?: Array<IExpand>;
  query?: IQueryObject | Array<IQueryObject> | string;
}

export interface IPrivateGetOptions extends IPublicGetOptions {

}

export enum QueryMethod {
  findOne,
  count,
  all
}

export interface IPublicQueryOptions {
  select?: Array<string>;
  query?: IQueryObject;
  orderBy?: ISortOptions;
  limit?: number;
  offset?: number;
  expandEntity?: Array<IExpand>;
  expandCollection?: Array<IExpand>;
}

export interface IPrivateQueryOptions extends IPublicQueryOptions {
  method?: QueryMethod;
  mode?: string;
  hideInternals?: boolean;
}

export interface IPublicRemoveOptions {

}

export interface IPrivateRemoveOptions extends IPublicRemoveOptions {

}

export enum LogicalOperatorType {
  and,
  or
}



export interface IQueryObject {}

export type CombinedQueryOperatorType = (
  'not' |
  'and' |
  'or'
);

export type ComparisonOperatorType = (
  '=' |
  '!=' |
  '>' |
  '<'|
  '>=' |
  '<=' |
  'in' |
  'notin' |
  'beginswith' |
  'contains' |
  'endswith'
);

export interface IQueryClause extends IQueryObject {
  attribute: string;
  operator: ComparisonOperatorType;
  value: any;
  type?: string;
  ignoreCase?: boolean;
  escapeAttribute?: boolean;
  fnTemplate?: string;
}

export interface ICombinedQueryClause extends IQueryObject {
  operator: CombinedQueryOperatorType;
  queries: Array<IQueryObject>;
}


export interface IExpand {
  attribute: string;
  childAttributes?: Array<IExpand>;
}



export interface IGetSchemasOptions {
  excludeAbstract: boolean;
}

export interface IAllSchemas extends ISchemas {

}

export interface IInheritedSchema extends ISchema {

}

export interface ISchemas {
  [key: string]: {
    [namespace: string]: ISchema;
  }
}

export interface ISchema {
  name?: string;
  namespace?: string;
  entityKey?: string;
  attributes: ISchemaAttributes;
  expandEntity: Array<IExpand>;
  expandCollection: Array<IExpand>;
  indexes: IIndexes;
  isAbstract: boolean;
  // this interface should not contain methods as this would impose
  // that we can only use instances of the Schema class here instead of anonymous objects
  // findAttribute(attrName: string): ISchemaAttribute;
}

export interface ISchemaClass {
  expandEntity?: Array<IExpand>;
  expandCollection?: Array<IExpand>;
  indexes?: IIndexes;
  isAbstract?: boolean;
}

export interface ISchemaAttributes {
  [attributeName: string]: ISchemaAttribute;
}

export interface IIndexes {
  [indexName: string]: IIndex;
}

export interface IIndex {
  type: string;
  fields: Array<string>;
}

export enum SchemaAttributeType {
  string,
  object,
  number,
  boolean,
  int,
  Date,
  Blob
}

export interface ICalculatedPropertyOnQueryCallback {
  (context: ExecutionContext, query: IQueryClause): IQueryObject;
}

export interface ICalculatedPropertyOnSortCallback {
  (sortProperty: ISortProperty): ISortOptions;
}

export interface ICalculatedAttributeDeclaration {
  onQuery?: ICalculatedPropertyOnQueryCallback;
  onSort?: ICalculatedPropertyOnSortCallback;
  onGet?: Function;
  onSet?: Function;
}

export interface ISortOptions {
  attributes: Array<ISortProperty>;
}

export interface ISortProperty {
  attribute: string;
  order: SortOrder;
}

export type SortOrder = (
  'asc' |
  'desc'
)

export interface ISchemaAttribute {
  type: SchemaAttributeType | string;
  isComplexType?: boolean;
  isEncrypted?: boolean;
  dbType?: string;
  internal?: boolean;
  calculated?: ICalculatedAttributeDeclaration;
  scope?: string;
  isPrimaryKey?: boolean;
  isInternal?: boolean;
  onInit?: Function;
  isList?: true;
  expandEntity?: Array<IExpand>;
  expandCollection?: Array<IExpand>;
  relatedAttribute?: string;
}

export const RegistrationKeySpacer = ':';

export const DefaultNamespace = undefined;

export interface INamingConventionService {
  getRegistrationKey(namespace: string, entityKey: string): string;
  parseRegistrationKey(registrationKey: string): IRegistrationKey;
  parseExpands(values: Array<string>): Array<IExpand>;
}

export interface IRegistrationKey {
  namespace: string;
  entityKey: string;
}

export interface IRequiredClaim {
  claim?: string;
  actions: Array<[ClaimActionType, Array<string>]>;
}

export enum ClaimActionType {
  create = 0,
  read = 1,
  write = 2,
  delete = 3,
  execute = 4,
  all = 5
}

export interface IPromotionRoles {
  roles: Array<string>;
}

export interface IIamService {
  authenticateByUsername(username: string, password: string, tokenType?: TokenType): Promise<string>;
  authenticateBySystemUser(systemUser: string, tokenType?: TokenType): Promise<string>;
  createInternalContext(systemUser: string, tokenType?: TokenType): Promise<ExecutionContext>;
  resolveExecutionContext(encodedToken: string, tokenType?: TokenType): Promise<ExecutionContext>;
  hasClaim(context: ExecutionContext, claim: string): Promise<boolean>;
  getIdentity(context: ExecutionContext): Promise<IIdentity>;
  getIdentityEntity(context: ExecutionContext): Promise<IUserEntity>;
  logout(context: ExecutionContext): Promise<boolean>;
  initialize(): void;
  flattenRoles(roles: Array<string>): Array<string>;
  getGuest(): IIdentity;
}

export interface IUserEntity extends IEntity, IIdentity {
  name: string;
  password: string;
}

export interface IIdentity {
  id: string;
  name: string;
  roles: Array<string>;
}

export type HttpMethod = 'POST'|'PUT'|'DELETE'|'GET';
