"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_contracts_1 = require("@process-engine-js/core_contracts");
const metadata_1 = require("@process-engine-js/metadata");
const uuidModule = require("uuid");
const toposort = require("toposort");
const strHash = require("string-hash");
const entity_reference_1 = require("./entity_reference");
const entity_collection_reference_1 = require("./entity_collection_reference");
const uuid = uuidModule;
class EntityDependencyHelper {
    constructor(datastoreServiceFactory, propertyBagFactory, encryptionService, invoker, entityType) {
        this._datastoreService = undefined;
        this._datastoreServiceFactory = undefined;
        this.propertyBagFactory = undefined;
        this.encryptionService = undefined;
        this.invoker = undefined;
        this.entityType = undefined;
        this._datastoreServiceFactory = datastoreServiceFactory;
        this.propertyBagFactory = propertyBagFactory;
        this.encryptionService = encryptionService;
        this.invoker = invoker;
        this.entityType = entityType;
    }
    get datastoreService() {
        if (!this._datastoreService) {
            this._datastoreService = this._datastoreServiceFactory();
        }
        return this._datastoreService;
    }
}
exports.EntityDependencyHelper = EntityDependencyHelper;
class Entity {
    constructor(entityDependencyHelper, context, schema) {
        this._entityDependencyHelper = undefined;
        this._propertyBag = undefined;
        this._derivedClassInstance = undefined;
        this._context = undefined;
        this._schema = undefined;
        this._options = undefined;
        this._entityDependencyHelper = entityDependencyHelper;
        this._context = context;
        this._schema = schema;
    }
    get context() {
        return this._context;
    }
    get schema() {
        return this._schema;
    }
    get invoker() {
        return this._entityDependencyHelper.invoker;
    }
    get entityType() {
        return this._entityDependencyHelper.entityType;
    }
    get encryptionService() {
        return this._entityDependencyHelper.encryptionService;
    }
    get propertyBag() {
        return this._propertyBag;
    }
    get datastoreService() {
        return this._entityDependencyHelper.datastoreService;
    }
    get isNew() {
        return this.propertyBag.isNew;
    }
    get isDirty() {
        return this.propertyBag.isDirty();
    }
    get propertyBagFactory() {
        return this._entityDependencyHelper.propertyBagFactory;
    }
    get derivedClassInstance() {
        return this._derivedClassInstance;
    }
    async initialize(derivedClassInstance) {
        if (!derivedClassInstance) {
            throw new Error('derived class instance is missing');
        }
        this._derivedClassInstance = derivedClassInstance;
        this._propertyBag = await this.createPropertyBag(this.schema);
    }
    async createPropertyBag(schema) {
        const additionalInjectionArgs = [this.context];
        const additionalPropertyBagConfig = undefined;
        const propertyBag = this.propertyBagFactory(additionalInjectionArgs, additionalPropertyBagConfig);
        const attributeKeys = Object.keys(schema.attributes);
        attributeKeys.forEach((attributeKey) => {
            const attribute = schema.attributes[attributeKey];
            if (attribute.calculated) {
                const getCallback = attribute.calculated.onGet;
                const setCallback = attribute.calculated.onSet;
                propertyBag.createCalculatedProperty(attribute, attributeKey, getCallback, setCallback);
            }
            else {
                const onInitCallback = attribute.onInit;
                propertyBag.createProperty(attribute, attributeKey, onInitCallback);
            }
        });
        await propertyBag.initialize();
        return propertyBag;
    }
    get id() {
        return this.getProperty(this, 'id');
    }
    set id(value) {
        this.setProperty(this, 'id', value);
    }
    getProperty(propertyThisContext, propertyName) {
        return this.propertyBag.getProperty(propertyThisContext, propertyName);
    }
    async getPropertyLazy(propertyThisContext, propertyName, context, options) {
        return this.propertyBag.getPropertyLazy(propertyThisContext, propertyName, context, options);
    }
    setProperty(propertyThisContext, propertyName, value) {
        const propertySchema = this.schema.attributes ? this.schema.attributes[propertyName] : undefined;
        if (propertySchema && propertySchema.isComplexType && value && !this._isResolvablelEntity(value)) {
            const valueType = typeof value;
            if (valueType === 'object' && value.id) {
                value = new entity_reference_1.EntityReference(this.schema.namespace, propertySchema.type, value.id);
            }
            else if (valueType === 'string') {
                value = new entity_reference_1.EntityReference(this.schema.namespace, propertySchema.type, value);
            }
            else {
                throw new Error(`unable to construct a resolvable entity representation for property ${propertyName} with data ${JSON.stringify(value)}!`);
            }
        }
        return this.propertyBag.setProperty(propertyThisContext, propertyName, value);
    }
    getCalculatedProperty(propertyThisContext, propertyName, context) {
        return this.propertyBag.getCalculatedProperty(propertyThisContext, propertyName, context);
    }
    setCalculatedProperty(propertyThisContext, propertyName, value, context) {
        return this.propertyBag.setCalculatedProperty(propertyThisContext, propertyName, value, context);
    }
    async toPojo(context, options) {
        const persistanceMode = options && options.mode && options.mode === core_contracts_1.SaveMode.persistance;
        const select = options && options.select ? options.select : undefined;
        options = options || {};
        if (!options.hasOwnProperty('_currentDepth')) {
            options._currentDepth = 0;
        }
        if (persistanceMode) {
            return this._toPojoForPersistance(context, options);
        }
        const currentDepth = options._currentDepth;
        const maxDepth = options.hasOwnProperty('maxDepth') ? options.maxDepth : 10;
        const datastoreService = this.datastoreService;
        const hideInternals = ((datastoreService && datastoreService.config && datastoreService.config.sealInternals) || (options && options.hideInternals));
        let data;
        if (maxDepth === undefined || currentDepth <= maxDepth) {
            let propertyKeysToExport = this.propertyBag.propertyKeys;
            if (select) {
                propertyKeysToExport = this._filterPropertyKeysBySelect(propertyKeysToExport, select);
            }
            if (hideInternals) {
                propertyKeysToExport = this._filterPropertyKeysByInternal(propertyKeysToExport);
            }
            propertyKeysToExport = await this._filterPropertyKeysByAccessAllowed(propertyKeysToExport, 'read');
            data = await this.propertyBag.toPojo(this.derivedClassInstance, context, options, propertyKeysToExport);
            if (!hideInternals) {
                const meta = {
                    type: this.entityType.name,
                    namespace: this.entityType.namespace,
                    isRef: false,
                    isNew: this.isNew
                };
                data._meta = meta;
            }
        }
        else {
            data = this.getEntityReference().toPojo();
        }
        return data;
    }
    async _toPojoForPersistance(context, options) {
        const saveFullEntity = options && options.saveFullEntity;
        const propertyKeysToExport = saveFullEntity ? this.propertyBag.propertyKeys : this.propertyBag.dirtyPropertyKeys;
        const propertyKeysWithWriteAccess = await this._filterPropertyKeysByAccessAllowed(propertyKeysToExport, 'write');
        if (propertyKeysToExport.length > propertyKeysWithWriteAccess.length) {
            throw new Error('insufficient write access');
        }
        options = options || {};
        options.maxDepth = 0;
        const data = await this.propertyBag.toPojo(this.derivedClassInstance, context, options, propertyKeysToExport);
        await this._encryptData(data);
        return data;
    }
    _filterPropertyKeysBySelect(propertyKeys, select) {
        return select.filter((propertyKey) => {
            return (propertyKeys.indexOf(propertyKey) !== -1);
        });
    }
    _filterPropertyKeysByInternal(propertyKeys) {
        return propertyKeys.filter((propertyKey) => {
            const attributeSchema = this.schema.attributes[propertyKey];
            return attributeSchema && !attributeSchema.isInternal;
        });
    }
    async _filterPropertyKeysByAccessAllowed(propertyKeys, claimActionFragment) {
        const propertyKeysWithAccess = [];
        const propertyAccessAllowedPromises = propertyKeys.map(async (propertyKey) => {
            const allowed = await this.propertyBag.isPropertyAccessAllowed(this.derivedClassInstance, propertyKey, claimActionFragment);
            if (allowed) {
                propertyKeysWithAccess.push(propertyKey);
            }
        });
        await Promise.all(propertyAccessAllowedPromises);
        return propertyKeysWithAccess;
    }
    async fromPojo(context, data, options) {
        const dataComesFromAdapter = options && options.mode && options.mode === core_contracts_1.SaveMode.persistance;
        if (data) {
            const propertyKeys = Object.keys(data);
            await this._resolveEntityReferences(data, propertyKeys);
            if (dataComesFromAdapter) {
                await this._fromRemotePojo(data, propertyKeys);
                await this._resolveEntityInstances(data, propertyKeys, options);
                if (context && context.entityCallStack) {
                    const namespace = this.entityType.namespace;
                    const entityId = this.id;
                    let entityCallStack = context.entityCallStack;
                    if (namespace && entityCallStack.hasOwnProperty(namespace) && entityCallStack[namespace]) {
                        entityCallStack = entityCallStack[namespace];
                    }
                    const hash = entityId + '_' + strHash(JSON.stringify(options.select) + JSON.stringify(options.expandEntity));
                    entityCallStack[hash] = this;
                    this._options = options;
                }
                await this._resolveEntityCollections(context, propertyKeys, options);
                await this.calculate(context, options);
            }
            else {
                this._filterAdapterMetadata(data, propertyKeys);
                await this._fromLocalPojo(data, propertyKeys);
            }
        }
    }
    async _resolveEntityCollections(context, propertyKeys, options) {
        const self = this;
        for (let i = 0; i < propertyKeys.length; i++) {
            const propertyKey = propertyKeys[i];
            const property = self.propertyBag.properties[propertyKey];
            if (property.isEntityCollectionReference()) {
                const ref = property.getValue(null);
                if (ref && ref.resolve) {
                    const queryOptions = {
                        query: {
                            attribute: ref.relatedAttribute,
                            operator: '=',
                            value: ref.id
                        }
                    };
                    let foundExpands;
                    const expandOption = options.expandCollection || options.expandEntity;
                    if (expandOption && (foundExpands = expandOption.filter((expand) => propertyKey === expand.attribute)) && foundExpands.length === 1) {
                        const expand = foundExpands[0];
                        if (expand.childAttributes && expand.childAttributes.length > 0) {
                            queryOptions.select = expand.childAttributes.map((child) => child.attribute);
                        }
                        queryOptions.expandCollection = expand.childAttributes;
                    }
                    const entityType = await self.datastoreService.getEntityType(ref.relatedType);
                    const coll = await entityType.query(context, queryOptions);
                    self.propertyBag.setProperty(self, propertyKey, coll);
                }
            }
        }
    }
    async calculate(context, options) {
        const select = options && options.select ? options.select : undefined;
        let propertyKeys = this.propertyBag.propertyKeys;
        if (select) {
            propertyKeys = this._filterPropertyKeysBySelect(propertyKeys, select);
        }
        const topSortEdges = [];
        for (let propertyKey in propertyKeys) {
            const property = this.propertyBag.properties[propertyKeys[propertyKey]];
            if (property.schema && property.schema.calculated) {
                if (property.schema.expandEntity) {
                    property.schema.expandEntity.forEach((expand) => {
                        topSortEdges.push([propertyKeys[propertyKey], expand.attribute]);
                    });
                }
                else {
                    topSortEdges.push([propertyKeys[propertyKey], 'root']);
                }
            }
        }
        const topSortResult = toposort(topSortEdges).reverse().filter((edge) => edge !== 'root');
        for (let propertyKey in topSortResult) {
            const property = this.propertyBag.properties[topSortResult[propertyKey]];
            if (property.schema && property.schema.calculated) {
                await property.getValueLazy(this, context);
            }
        }
    }
    _isResolvablelEntity(value) {
        return (value instanceof entity_reference_1.EntityReference || value instanceof Entity);
    }
    _filterAdapterMetadata(data, propertyKeys) {
        if (propertyKeys.indexOf('_meta') !== -1) {
            propertyKeys.splice(propertyKeys.indexOf('_meta'), 1);
            delete data._meta;
        }
    }
    async _resolveEntityInstances(data, propertyKeys, options) {
        const resolvePromises = propertyKeys.map(async (propertyKey) => {
            const propertyValue = data[propertyKey];
            const propertySchema = this.schema.attributes ? this.schema.attributes[propertyKey] : undefined;
            if (propertySchema && propertySchema.isComplexType) {
                if (typeof propertyValue === 'undefined' || propertyValue === null || (propertyValue instanceof entity_reference_1.EntityReference) || (propertyValue instanceof entity_collection_reference_1.EntityCollectionReference)) {
                    return;
                }
                const entityType = await this.datastoreService.getEntityType(propertySchema.type);
                const createEntityOption = Object.assign({}, options);
                let foundExpands;
                if (createEntityOption.expandEntity && (foundExpands = createEntityOption.expandEntity.filter((expand) => propertyKey === expand.attribute)) && foundExpands.length === 1) {
                    const expand = foundExpands[0];
                    if (expand.childAttributes && expand.childAttributes.length > 0) {
                        createEntityOption.select = expand.childAttributes.map((child) => child.attribute);
                    }
                    createEntityOption.expandEntity = expand.childAttributes;
                }
                const entity = await entityType.createEntity(this.context, propertyValue, createEntityOption);
                data[propertyKey] = entity;
                this.propertyBag.setProperty(this, propertyKey, entity);
            }
        });
        await Promise.all(resolvePromises);
    }
    async _resolveEntityReferences(data, propertyKeys) {
        const resolvePromises = propertyKeys.map(async (propertyKey) => {
            const propertyValue = data[propertyKey];
            const propertySchema = this.schema.attributes ? this.schema.attributes[propertyKey] : undefined;
            const valueType = typeof propertyValue;
            if (valueType === 'undefined' || propertyValue === null) {
                return;
            }
            if (propertySchema && propertySchema.isComplexType) {
                if (propertySchema.isList) {
                    const collectionReference = new entity_collection_reference_1.EntityCollectionReference(this.schema.namespace, propertySchema.type, propertyValue.id, propertySchema.type, propertySchema.relatedAttribute, propertyValue.resolve);
                    data[propertyKey] = collectionReference;
                }
                else if (valueType === 'string') {
                    const entityReference = new entity_reference_1.EntityReference(this.schema.namespace, propertySchema.type, propertyValue);
                    data[propertyKey] = entityReference;
                }
                else {
                    if (typeof propertyValue === 'object' && propertyValue._meta && propertyValue._meta.isRef && propertyValue.id) {
                        const entityReference = new entity_reference_1.EntityReference(this.schema.namespace, propertySchema.type, propertyValue.id);
                        data[propertyKey] = entityReference;
                    }
                }
            }
        });
        await Promise.all(resolvePromises);
    }
    async _fromRemotePojo(data, propertyKeys) {
        const isAccessAllowedPromises = propertyKeys.map(async (propertyKey) => {
            const isAccessAllowed = await this.propertyBag.isPropertyAccessAllowed(this.derivedClassInstance, propertyKey, 'read');
            if (!isAccessAllowed) {
                delete data[propertyKey];
            }
        });
        await Promise.all(isAccessAllowedPromises);
        await this._decryptData(data);
        this.propertyBag.updateFromRemote(data);
    }
    async _fromLocalPojo(data, propertyKeys) {
        const isWriteAccessAllowed = await this.propertyBag.isAccessAllowed(this.derivedClassInstance, propertyKeys, 'write');
        if (!isWriteAccessAllowed) {
            throw new Error('access to write properties declined');
        }
        this.propertyBag.updateFromLocal(data, this);
    }
    async _encryptData(data) {
        const keys = Object.keys(data);
        const encryptPromises = keys.map(async (propertyKey) => {
            const attributeSchema = this.schema.attributes[propertyKey];
            const value = data[propertyKey];
            if (attributeSchema.isEncrypted) {
                const encryptedValue = await this.encryptionService.encrypt(value);
                data[propertyKey] = encryptedValue;
            }
        });
        await Promise.all(encryptPromises);
    }
    async _decryptData(data) {
        const keys = Object.keys(data);
        const decryptPromises = keys.map(async (propertyKey) => {
            const attributeSchema = this.schema.attributes[propertyKey];
            const value = data[propertyKey];
            if (attributeSchema.isEncrypted) {
                const decryptedValue = await this.encryptionService.decrypt(value);
                data[propertyKey] = decryptedValue;
            }
        });
        await Promise.all(decryptPromises);
    }
    async save(context, options) {
        const reloadAfterSave = options && options.hasOwnProperty('reloadAfterSave') ? options.reloadAfterSave : true;
        const savedEntity = await this.entityType.save(this, context, options);
        if (!reloadAfterSave) {
            this.propertyBag.isNew = false;
        }
        return savedEntity;
    }
    async remove(context, options) {
        await this.entityType.remove(this, context, options);
    }
    getEntityReference() {
        return new entity_reference_1.EntityReference(this.schema.namespace, this.entityType.name, this.id);
    }
}
__decorate([
    metadata_1.schemaAttribute({
        type: core_contracts_1.SchemaAttributeType.string,
        isPrimaryKey: true,
        onInit: function () {
            return uuid.v4();
        }
    })
], Entity.prototype, "id", null);
exports.Entity = Entity;

//# sourceMappingURL=entity.js.map
