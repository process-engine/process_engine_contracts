"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_contracts_1 = require("@process-engine-js/core_contracts");
class EntityCollection {
    constructor(entityType, entityDataSets, count, offset, limit, options) {
        this._data = [];
        this.count = 0;
        this.offset = 0;
        this.limit = null;
        this._options = undefined;
        this._entityType = undefined;
        this._entityType = entityType;
        if (entityDataSets) {
            entityDataSets.forEach((entityDataSet) => {
                this._data.push(entityDataSet);
            });
            this.count = (count !== undefined) ? count : this._data.length;
            this.offset = offset || 0;
            this.limit = limit || null;
            this._options = Object.assign({}, options);
        }
    }
    get data() {
        return this._data;
    }
    get length() {
        return this.count;
    }
    async toPojos(context, options) {
        let toPojoResults = [];
        if (this.length > 0) {
            const toPojoResultPromises = this.data.map(async (entity) => {
                const pojo = await entity.toPojo(context, options);
                return pojo;
            });
            toPojoResults = await Promise.all(toPojoResultPromises);
        }
        const result = {
            count: this.count,
            offset: this.offset,
            limit: this.limit,
            data: toPojoResults
        };
        return result;
    }
    async each(context, callback) {
        for (let i = 0; i < this.count; i++) {
            if ((i < this.offset) || (i > (this.offset + this.limit - 1))) {
                const offset = i;
                const limit = 10;
                await this._loadMore(context, offset, limit);
            }
            const entity = this._data[i];
            await callback(entity, i);
        }
    }
    add(entity, distinct) {
        if (!entity || typeof entity !== 'object') {
            throw new Error(`the entity to be added must be a valid object`);
        }
        let doAdd = true;
        if (distinct) {
            const foundEntities = this._data.filter((entityToAdd) => entityToAdd.id === entity.id);
            if (foundEntities.length > 0) {
                doAdd = false;
            }
        }
        if (doAdd) {
            this._data.push(entity);
            this.count++;
            this.limit++;
        }
        return this;
    }
    async addCollection(context, entityCollection, distinct) {
        return this._addCollection(context, entityCollection, distinct);
    }
    async addCollectionDistinct(context, entityCollection) {
        return this._addCollection(context, entityCollection, true);
    }
    async _addCollection(context, entityCollection, distinct) {
        if (!entityCollection || typeof entityCollection !== 'object' || !entityCollection.data) {
            throw new Error(`the entity collection to be added must be a valid collection containing data`);
        }
        await entityCollection.each(context, async (entity) => {
            this.add(entity, distinct);
        });
        return this;
    }
    async _loadMore(context, offset, limit) {
        const options = Object.assign({}, this._options);
        options.offset = offset;
        options.limit = limit;
        const result = await this._entityType.dataSource.query(options);
        if (result && result.entities) {
            const fromPojoOptions = {
                mode: core_contracts_1.SaveMode.persistance,
                select: options.select,
                expandEntity: options.expandEntity,
                expandCollection: options.expandCollection
            };
            for (let i = 0; i < result.entities.length; i++) {
                const pojo = result.entities[i];
                const entity = await this._entityType.createEntity(context);
                await entity.fromPojo(context, pojo, fromPojoOptions);
                const pos = offset < this.offset ? 0 : offset;
                this.data.splice(pos + i, 0, entity);
            }
        }
        if (this.offset > offset) {
            this.offset = offset;
        }
        if ((this.offset + this.limit) < (offset + limit)) {
            this.limit = (offset + limit - this.offset);
        }
    }
}
exports.EntityCollection = EntityCollection;

//# sourceMappingURL=entity_collection.js.map
