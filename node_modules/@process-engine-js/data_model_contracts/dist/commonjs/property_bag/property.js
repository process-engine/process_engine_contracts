"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interfaces_1 = require("./../interfaces");
const entity_reference_1 = require("./../entity_reference");
const entity_collection_reference_1 = require("./../entity_collection_reference");
const entity_collection_1 = require("./../entity_collection");
const copy = require("deepcopy");
const deepEqual = require("deep-equal");
const strHash = require("string-hash");
class Property {
    constructor(schema, datastoreServiceFactory, context, onInitCallback) {
        this._schema = undefined;
        this._datastoreServiceFactory = undefined;
        this._datastoreService = undefined;
        this._context = undefined;
        this._onInitCallback = undefined;
        this._remoteValue = undefined;
        this._value = undefined;
        this._schema = schema;
        this._datastoreServiceFactory = datastoreServiceFactory;
        this._context = context;
        this._onInitCallback = onInitCallback;
    }
    get schema() {
        return this._schema;
    }
    get datastoreService() {
        if (!this._datastoreService) {
            this._datastoreService = this._datastoreServiceFactory();
        }
        return this._datastoreService;
    }
    get context() {
        return this._context;
    }
    get onInitCallback() {
        return this._onInitCallback;
    }
    get remoteValue() {
        return this._remoteValue;
    }
    set remoteValue(value) {
        this._remoteValue = value;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    isDirty() {
        return !deepEqual(this.value, this.remoteValue);
    }
    isEntityReference() {
        return this._isEntityReference(this.value);
    }
    isEntityCollectionReference() {
        return this._isEntityCollectionReference(this.value);
    }
    async initializeValue() {
        if (this.onInitCallback) {
            const initialValue = await this.onInitCallback();
            this.value = initialValue;
        }
    }
    getValue(valueSource) {
        return this._getCurrentValue();
    }
    async getValueLazy(valueSource, context, options) {
        const currentValue = this._getCurrentValue();
        const isEntityReference = this._isEntityReference(currentValue);
        const isEntityCollectionReference = this._isEntityCollectionReference(currentValue);
        if (isEntityCollectionReference || currentValue instanceof entity_collection_1.EntityCollection) {
            if (!isEntityCollectionReference) {
                return currentValue;
            }
            else {
                const baseQuery = {
                    attribute: currentValue.relatedAttribute,
                    operator: '=',
                    value: currentValue.id
                };
                const queryOptions = (options || {});
                if (queryOptions.query) {
                    queryOptions.query = {
                        operator: 'and',
                        queries: [
                            queryOptions.query,
                            baseQuery
                        ]
                    };
                }
                else {
                    queryOptions.query = baseQuery;
                }
                const coll = await this._getEntityCollectionByReference(currentValue.relatedType, context, queryOptions);
                this.remoteValue = this.value;
                this.value = coll;
                return coll;
            }
        }
        else {
            let entity;
            let entityCallStack = context && context.entityCallStack ? context.entityCallStack : null;
            let options;
            if (currentValue) {
                if (isEntityReference) {
                    const entityType = await this.datastoreService.getEntityType(currentValue.type);
                    options = {};
                    options.expandEntity = entityType.getDefaultExpandOptions(interfaces_1.ExpandType.Entity);
                }
                else {
                    options = currentValue._options || {};
                }
                const id = currentValue.id;
                const hash = id + '_' + strHash(JSON.stringify(options.select) + JSON.stringify(options.expandEntity));
                let cachedEntity;
                if (entityCallStack) {
                    const namespace = currentValue.namespace;
                    if (namespace && entityCallStack.hasOwnProperty(namespace) && entityCallStack[namespace]) {
                        entityCallStack = entityCallStack[namespace];
                    }
                    if (entityCallStack.hasOwnProperty(hash)) {
                        cachedEntity = entityCallStack[hash];
                    }
                }
                if (!isEntityReference) {
                    if (cachedEntity) {
                        return cachedEntity;
                    }
                    return currentValue;
                }
                else {
                    if (cachedEntity) {
                        entity = cachedEntity;
                    }
                    else {
                        entity = await this._getEntityByReference(currentValue, context, options);
                    }
                }
            }
            else {
                entity = null;
            }
            this.remoteValue = this.value;
            this.value = entity;
            return entity;
        }
    }
    setValue(valueTarget, value) {
        this._value = value;
    }
    updateFromRemote(remoteValue) {
        this._remoteValue = remoteValue;
        this._value = copy(remoteValue);
    }
    _getCurrentValue() {
        return this.value === undefined ? this.remoteValue : this.value;
    }
    _isEntityReference(value) {
        return value instanceof entity_reference_1.EntityReference;
    }
    _isEntityCollectionReference(value) {
        return value instanceof entity_collection_reference_1.EntityCollectionReference;
    }
    async _getEntityByReference(value, context, options) {
        const entityReference = value;
        const entityType = await this.datastoreService.getEntityType(entityReference.type);
        const entity = await entityType.getById(entityReference.id, context, options);
        return entity;
    }
    async _getEntityCollectionByReference(entityCollectionTypeKey, context, options) {
        const entityCollectionType = await this.datastoreService.getEntityType(entityCollectionTypeKey);
        const coll = await entityCollectionType.query(context, options);
        return coll;
    }
}
exports.Property = Property;

//# sourceMappingURL=property.js.map
