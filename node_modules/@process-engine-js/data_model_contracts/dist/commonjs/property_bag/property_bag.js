"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const property_1 = require("./property");
const calculated_property_1 = require("./calculated_property");
const entity_collection_1 = require("../entity_collection");
const core_contracts_1 = require("@process-engine-js/core_contracts");
const BluebirdPromise = require("bluebird");
class PropertyBag {
    constructor(datastoreServiceFactory, metadataProvider, iamService, context) {
        this._datastoreServiceFactory = undefined;
        this._metadataProvider = undefined;
        this._iamService = undefined;
        this._context = undefined;
        this._properties = {};
        this._propertyChangedCallbacks = {};
        this.isNew = true;
        this._datastoreServiceFactory = datastoreServiceFactory;
        this._metadataProvider = metadataProvider;
        this._iamService = iamService;
        this._context = context;
    }
    get datastoreServiceFactory() {
        return this._datastoreServiceFactory;
    }
    get metadataProvider() {
        return this._metadataProvider;
    }
    get iamService() {
        return this._iamService;
    }
    get context() {
        return this._context;
    }
    get properties() {
        return this._properties;
    }
    get propertyChangedCallbacks() {
        return this._propertyChangedCallbacks;
    }
    get propertyKeys() {
        return Object.keys(this.properties);
    }
    get dirtyPropertyKeys() {
        return this.propertyKeys.filter((propertyKey) => {
            const property = this._getProperty(propertyKey);
            return property.isDirty();
        });
    }
    async initialize() {
        const initializeValuePromises = this.propertyKeys.map(async (propertyKey) => {
            const property = this._getProperty(propertyKey);
            await property.initializeValue();
        });
        await Promise.all(initializeValuePromises);
    }
    async toPojo(propertyThisContext, context, options, propertyKeys) {
        const propertyKeysToExport = propertyKeys || this.propertyKeys;
        const result = {};
        const bag = this;
        async function exportProperty(propertyKey) {
            const property = bag._getProperty(propertyKey);
            if (property !== undefined) {
                const isEntityReference = property.isEntityReference();
                const isEntityCollectionReference = property.isEntityCollectionReference();
                const isComplexType = property.schema.isComplexType;
                const isCalculated = !!property.schema.calculated;
                let value;
                if (isCalculated) {
                    if (options && options.skipCalculation) {
                        value = bag.getProperty(propertyThisContext, propertyKey);
                    }
                    else {
                        value = await bag.getCalculatedProperty(propertyThisContext, propertyKey, context);
                    }
                }
                else {
                    value = bag.getProperty(propertyThisContext, propertyKey);
                }
                if (isComplexType) {
                    if ((isEntityCollectionReference || value instanceof entity_collection_1.EntityCollection) && value !== null && value !== undefined) {
                        if (!isEntityCollectionReference) {
                            let relPojoOptions = Object.assign({}, options);
                            relPojoOptions._currentDepth = relPojoOptions._currentDepth + 1;
                            if (options && options.mode && options.mode === core_contracts_1.SaveMode.persistance) {
                                relPojoOptions = {
                                    _currentDepth: relPojoOptions._currentDepth,
                                    maxDepth: relPojoOptions.maxDepth
                                };
                            }
                            return result[propertyKey] = await value.toPojos(context, relPojoOptions);
                        }
                        return result[propertyKey] = value.toPojo();
                    }
                    if (!isEntityReference && value !== null && value !== undefined) {
                        let relPojoOptions = Object.assign({}, options);
                        relPojoOptions._currentDepth = relPojoOptions._currentDepth + 1;
                        if (options && options.mode && options.mode === core_contracts_1.SaveMode.persistance) {
                            relPojoOptions = {
                                _currentDepth: relPojoOptions._currentDepth,
                                maxDepth: relPojoOptions.maxDepth
                            };
                        }
                        return value.toPojo(context, relPojoOptions)
                            .then((pojo) => {
                            result[propertyKey] = pojo;
                        });
                    }
                    else if (isEntityReference && value !== null && value !== undefined) {
                        return result[propertyKey] = value.toPojo();
                    }
                }
                return result[propertyKey] = value;
            }
        }
        const promises = propertyKeysToExport.map((propertyKey) => exportProperty(propertyKey));
        return BluebirdPromise.all(promises)
            .then(() => result);
    }
    isDirty() {
        const isDirty = this.propertyKeys.some((propertyKey) => {
            const property = this._getProperty(propertyKey);
            return property.isDirty();
        });
        return isDirty;
    }
    _getProperty(propertyName) {
        return this.properties[propertyName];
    }
    _setProperty(propertyName, property) {
        this.properties[propertyName] = property;
    }
    getProperty(propertyThisContext, propertyName) {
        const property = this._getProperty(propertyName);
        const value = property.getValue(propertyThisContext);
        return value;
    }
    async getPropertyLazy(propertyThisContext, propertyName, context, options) {
        const property = this._getProperty(propertyName);
        const value = await property.getValueLazy(propertyThisContext, context, options);
        return value;
    }
    setProperty(propertyThisContext, propertyName, value) {
        const property = this._getProperty(propertyName);
        property.setValue(propertyThisContext, value);
    }
    async getCalculatedProperty(propertyThisContext, propertyName, context) {
        const property = this._getProperty(propertyName);
        const value = await property.getValueLazy(propertyThisContext, context);
        return value;
    }
    async setCalculatedProperty(propertyThisContext, propertyName, value, context) {
        const property = this._getProperty(propertyName);
        property.setValueLazy(propertyThisContext, value, context);
    }
    createProperty(schema, propertyName, onInitCallback) {
        const property = new property_1.Property(schema, this.datastoreServiceFactory, this.context, onInitCallback);
        this._setProperty(propertyName, property);
    }
    createCalculatedProperty(schema, propertyName, getCallback, setCallback) {
        let property = this._getProperty(propertyName);
        if (property) {
            throw new Error(`property for name ${propertyName} is already declared.`);
        }
        property = new calculated_property_1.CalculatedProperty(schema, this.datastoreServiceFactory, this.context, propertyName, getCallback, setCallback);
        this._setProperty(propertyName, property);
    }
    updateFromLocal(data, propertyThisContext) {
        this._setPropertyValues(data, false, propertyThisContext);
    }
    updateFromRemote(data) {
        this.isNew = false;
        this._setPropertyValues(data, true);
    }
    _setPropertyValues(data, fromRemote, propertyThisContext) {
        const propertyKeys = Object.keys(data);
        propertyKeys.map((propertyKey) => {
            const property = this._getProperty(propertyKey);
            if (property) {
                const value = data[propertyKey];
                if (fromRemote) {
                    property.updateFromRemote(value);
                }
                else {
                    property.setValue(propertyThisContext, value);
                }
            }
        });
    }
    async isAccessAllowed(propertyThisContext, propertyKeys, claimActionFragment) {
        const declinedProperties = [];
        const isAccessDeclinedPromises = propertyKeys.map(async (propertyKey) => {
            const isAccessAllowed = await this.isPropertyAccessAllowed(propertyThisContext, propertyKey, claimActionFragment);
            if (!isAccessAllowed) {
                declinedProperties.push(propertyKey);
            }
        });
        await Promise.all(isAccessDeclinedPromises);
        return declinedProperties.length === 0;
    }
    async isPropertyAccessAllowed(propertyThisContext, propertyName, claimActionFragment) {
        const typeName = propertyThisContext.constructor.name;
        const claim = `${typeName}.${propertyName}.${claimActionFragment}`;
        const isAllowed = await this.iamService.hasClaim(this.context, claim);
        return isAllowed;
    }
}
exports.PropertyBag = PropertyBag;

//# sourceMappingURL=property_bag.js.map
