import { IEncryptionService, IDatastoreService, IEntityType, IPropertyBag } from './interfaces';
import { ExecutionContext, IEntity, IFactory, IInheritedSchema, IToPojoOptions, IFromPojoOptions, IPrivateSaveOptions, IPrivateRemoveOptions, IEntityReference, IPrivateQueryOptions } from '@process-engine-js/core_contracts';
import { IInvoker } from '@process-engine-js/invocation_contracts';
export declare class EntityDependencyHelper {
    private _datastoreService;
    private _datastoreServiceFactory;
    propertyBagFactory: IFactory<IPropertyBag>;
    encryptionService: IEncryptionService;
    invoker: IInvoker;
    entityType: IEntityType<IEntity>;
    constructor(datastoreServiceFactory: IFactory<IDatastoreService>, propertyBagFactory: IFactory<IPropertyBag>, encryptionService: IEncryptionService, invoker: IInvoker, entityType: IEntityType<IEntity>);
    readonly datastoreService: IDatastoreService;
}
export declare class Entity implements IEntity {
    private _entityDependencyHelper;
    private _propertyBag;
    private _derivedClassInstance;
    private _context;
    private _schema;
    private _options;
    constructor(entityDependencyHelper: EntityDependencyHelper, context: ExecutionContext, schema: IInheritedSchema);
    readonly context: ExecutionContext;
    readonly schema: IInheritedSchema;
    protected readonly invoker: IInvoker;
    protected readonly entityType: IEntityType<IEntity>;
    protected readonly encryptionService: IEncryptionService;
    protected readonly propertyBag: IPropertyBag;
    protected readonly datastoreService: IDatastoreService;
    readonly isNew: boolean;
    readonly isDirty: boolean;
    private readonly propertyBagFactory;
    private readonly derivedClassInstance;
    initialize(derivedClassInstance: IEntity): Promise<void>;
    private createPropertyBag(schema);
    id: string;
    getProperty(propertyThisContext: any, propertyName: string): any;
    getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any>;
    setProperty(propertyThisContext: any, propertyName: string, value: any): void;
    getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any>;
    setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void>;
    toPojo(context: ExecutionContext, options?: IToPojoOptions): Promise<any>;
    private _toPojoForPersistance(context, options?);
    private _filterPropertyKeysBySelect(propertyKeys, select);
    private _filterPropertyKeysByInternal(propertyKeys);
    private _filterPropertyKeysByAccessAllowed(propertyKeys, claimActionFragment);
    fromPojo(context: ExecutionContext, data: any, options?: IFromPojoOptions): Promise<void>;
    private _resolveEntityCollections(context, propertyKeys, options?);
    calculate(context: ExecutionContext, options?: IFromPojoOptions): Promise<void>;
    private _isResolvablelEntity(value);
    private _filterAdapterMetadata(data, propertyKeys);
    private _resolveEntityInstances(data, propertyKeys, options?);
    private _resolveEntityReferences(data, propertyKeys);
    private _fromRemotePojo(data, propertyKeys);
    private _fromLocalPojo(data, propertyKeys);
    private _encryptData(data);
    private _decryptData(data);
    save(context: ExecutionContext, options?: IPrivateSaveOptions): Promise<IEntity>;
    remove(context: ExecutionContext, options?: IPrivateRemoveOptions): Promise<void>;
    getEntityReference(): IEntityReference;
}
