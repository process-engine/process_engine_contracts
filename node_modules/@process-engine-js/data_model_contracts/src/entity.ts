import {IEncryptionService, IDatastoreService, IEntityType, IPropertyBag} from './interfaces';
import {
  ExecutionContext, IEntity, IFactory, IInheritedSchema, IToPojoOptions, IFromPojoOptions, SaveMode,
  IPrivateSaveOptions, IPrivateRemoveOptions, ISchemas, SchemaAttributeType, IPojoMetadata, IEntityReference, IPrivateQueryOptions
} from '@process-engine-js/core_contracts';
import {IInvoker} from '@process-engine-js/invocation_contracts';
import { schemaAttribute } from '@process-engine-js/metadata';
import * as uuidModule from 'uuid';
import * as toposort from 'toposort';
import * as strHash from 'string-hash';

import {EntityReference} from './entity_reference';
import { EntityCollectionReference } from './entity_collection_reference';

const uuid: any = uuidModule;

export class EntityDependencyHelper {

  private _datastoreService: IDatastoreService = undefined;
  private _datastoreServiceFactory: IFactory<IDatastoreService> = undefined;

  public propertyBagFactory: IFactory<IPropertyBag> = undefined;
  public encryptionService: IEncryptionService = undefined;
  public invoker: IInvoker = undefined;
  public entityType: IEntityType<IEntity> = undefined;

  constructor(datastoreServiceFactory: IFactory<IDatastoreService>, propertyBagFactory: IFactory<IPropertyBag>, encryptionService: IEncryptionService, invoker: IInvoker, entityType: IEntityType<IEntity>) {
    this._datastoreServiceFactory = datastoreServiceFactory;
    this.propertyBagFactory = propertyBagFactory;
    this.encryptionService = encryptionService;
    this.invoker = invoker;
    this.entityType = entityType;
  }

  public get datastoreService(): IDatastoreService {
    if (!this._datastoreService) {
      this._datastoreService = this._datastoreServiceFactory();
    }
    return this._datastoreService;
  }
}

export class Entity implements IEntity {

  private _entityDependencyHelper: EntityDependencyHelper = undefined;
  private _propertyBag: IPropertyBag = undefined;
  private _derivedClassInstance: IEntity = undefined;
  private _context: ExecutionContext = undefined;
  private _schema: IInheritedSchema = undefined;
  private _options: IFromPojoOptions = undefined;

  constructor(entityDependencyHelper: EntityDependencyHelper, context: ExecutionContext, schema: IInheritedSchema) {
    this._entityDependencyHelper = entityDependencyHelper;
    this._context = context;
    this._schema = schema;
  }

  public get context(): ExecutionContext {
    return this._context;
  }

  public get schema(): IInheritedSchema {
    return this._schema;
  }

  protected get invoker(): IInvoker {
    return this._entityDependencyHelper.invoker;
  }

  protected get entityType(): IEntityType<IEntity> {
    return this._entityDependencyHelper.entityType;
  }

  protected get encryptionService(): IEncryptionService {
    return this._entityDependencyHelper.encryptionService;
  }

  protected get propertyBag(): IPropertyBag {
    return this._propertyBag;
  }

  protected get datastoreService(): IDatastoreService {
    return this._entityDependencyHelper.datastoreService;
  }

  public get isNew(): boolean {
    return this.propertyBag.isNew;
  }

  public get isDirty(): boolean {
    return this.propertyBag.isDirty();
  }

  private get propertyBagFactory(): IFactory<IPropertyBag> {
    return this._entityDependencyHelper.propertyBagFactory;
  }

  private get derivedClassInstance(): IEntity {
    return this._derivedClassInstance;
  }

  public async initialize(derivedClassInstance: IEntity): Promise<void> {
    if (!derivedClassInstance) {
      throw new Error('derived class instance is missing');
    }
    this._derivedClassInstance = derivedClassInstance;
    this._propertyBag = await this.createPropertyBag(this.schema);
  }

  private async createPropertyBag(schema: IInheritedSchema): Promise<IPropertyBag> {

    const additionalInjectionArgs = [this.context];
    const additionalPropertyBagConfig = undefined;

    const propertyBag = this.propertyBagFactory(additionalInjectionArgs, additionalPropertyBagConfig);

    const attributeKeys = Object.keys(schema.attributes);

    attributeKeys.forEach((attributeKey) => {

      const attribute = schema.attributes[attributeKey];

      if (attribute.calculated) {

        const getCallback = attribute.calculated.onGet;
        const setCallback = attribute.calculated.onSet;

        propertyBag.createCalculatedProperty(attribute, attributeKey, getCallback, setCallback);
      
      } else {
        
        const onInitCallback = attribute.onInit;

        propertyBag.createProperty(attribute, attributeKey, onInitCallback);
      }
    });

    await propertyBag.initialize();

    return propertyBag;
  }

  @schemaAttribute({
    type: SchemaAttributeType.string,
    isPrimaryKey: true,
    onInit: function() {
      return uuid.v4();
    }
  })
  public get id(): string {
    return this.getProperty(this, 'id');
  }

  public set id(value: string) {
    this.setProperty(this, 'id', value);
  }

  public getProperty(propertyThisContext: any, propertyName: string): any {
    return this.propertyBag.getProperty(propertyThisContext, propertyName);
  }

  public async getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any> {
    return this.propertyBag.getPropertyLazy(propertyThisContext, propertyName, context, options);
  }

  public setProperty(propertyThisContext: any, propertyName: string, value: any): void {
    const propertySchema = this.schema.attributes ? this.schema.attributes[propertyName] : undefined;
    if (propertySchema && propertySchema.isComplexType && value && !this._isResolvablelEntity(value)) {
      const valueType = typeof value;
      if (valueType === 'object' && value.id) {
        value = new EntityReference(this.schema.namespace, <string>propertySchema.type, value.id);
      } else if (valueType === 'string') {
        value = new EntityReference(this.schema.namespace, <string>propertySchema.type, value);
      } else {
        throw new Error(`unable to construct a resolvable entity representation for property ${propertyName} with data ${JSON.stringify(value)}!`);
      }
    }

    return this.propertyBag.setProperty(propertyThisContext, propertyName, value);
  }

  public getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any> {
    return this.propertyBag.getCalculatedProperty(propertyThisContext, propertyName, context);
  }

  public setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void> {
    return this.propertyBag.setCalculatedProperty(propertyThisContext, propertyName, value, context);
  }

  public async toPojo(context: ExecutionContext, options?: IToPojoOptions): Promise<any> {

    const persistanceMode = options && options.mode && options.mode === SaveMode.persistance;
    const select = options && options.select ? options.select : undefined;

    options = options || {};
    if (!options.hasOwnProperty('_currentDepth')) {
      options._currentDepth = 0;
    }

    if (persistanceMode) {
      return this._toPojoForPersistance(context, options);
    }

    
    const currentDepth = options._currentDepth;
    const maxDepth = options.hasOwnProperty('maxDepth') ? options.maxDepth : 10;

    const datastoreService = this.datastoreService;
    const hideInternals = ((datastoreService && datastoreService.config && datastoreService.config.sealInternals) || (options && options.hideInternals));

    let data;

    if (maxDepth === undefined || currentDepth <= maxDepth) {

      let propertyKeysToExport = this.propertyBag.propertyKeys;
      
      if (select) {
        propertyKeysToExport = this._filterPropertyKeysBySelect(propertyKeysToExport, select);
      }

      if (hideInternals) {
        propertyKeysToExport = this._filterPropertyKeysByInternal(propertyKeysToExport);
      }

      propertyKeysToExport = await this._filterPropertyKeysByAccessAllowed(propertyKeysToExport, 'read');

      data = await this.propertyBag.toPojo(this.derivedClassInstance, context, options, propertyKeysToExport);

      if (!hideInternals) {

        const meta: IPojoMetadata = {
          type: this.entityType.name,
          namespace: this.entityType.namespace,
          isRef: false,
          isNew: this.isNew
        };

        data._meta = meta;
      }
    } else {
      data = this.getEntityReference().toPojo();
    }
    
    return data;
  }

  private async _toPojoForPersistance(context: ExecutionContext, options?: IToPojoOptions): Promise<any> {
    
    const saveFullEntity = options && options.saveFullEntity;

    const propertyKeysToExport = saveFullEntity ? this.propertyBag.propertyKeys : this.propertyBag.dirtyPropertyKeys;

    const propertyKeysWithWriteAccess = await this._filterPropertyKeysByAccessAllowed(propertyKeysToExport, 'write');

    if (propertyKeysToExport.length > propertyKeysWithWriteAccess.length) {
      throw new Error('insufficient write access');
    }
    
    options = options || {};
    options.maxDepth = 0;

    const data = await this.propertyBag.toPojo(this.derivedClassInstance, context, options, propertyKeysToExport);

    await this._encryptData(data);

    return data;
  }

  private _filterPropertyKeysBySelect(propertyKeys: Array<string>, select: Array<string>): Array<string> {
    return select.filter((propertyKey) => {
      return (propertyKeys.indexOf(propertyKey) !== -1);
    });
  }

  private _filterPropertyKeysByInternal(propertyKeys: Array<string>): Array<string> {

    return propertyKeys.filter((propertyKey) => {

      const attributeSchema = this.schema.attributes[propertyKey];

      return attributeSchema && !attributeSchema.isInternal;
    });
  }

  private async _filterPropertyKeysByAccessAllowed(propertyKeys: Array<string>, claimActionFragment: string): Promise<Array<string>> {

    const propertyKeysWithAccess = [];

    const propertyAccessAllowedPromises = propertyKeys.map(async (propertyKey) => {

      const allowed = await this.propertyBag.isPropertyAccessAllowed(this.derivedClassInstance, propertyKey, claimActionFragment);

      if (allowed) {

        propertyKeysWithAccess.push(propertyKey);
      }
    });

    await Promise.all(propertyAccessAllowedPromises);

    return propertyKeysWithAccess;
  }

  public async fromPojo(context: ExecutionContext, data: any, options?: IFromPojoOptions): Promise<void> {

    const dataComesFromAdapter = options && options.mode && options.mode === SaveMode.persistance;

    if (data) {

      const propertyKeys = Object.keys(data);
      
      await this._resolveEntityReferences(data, propertyKeys);

      if (dataComesFromAdapter) {
        
        await this._fromRemotePojo(data, propertyKeys);

        await this._resolveEntityInstances(data, propertyKeys, options);

        // Caching level for entities resolved within the same context - cache uncalculated entity
        if (context && context.entityCallStack) {
          const namespace = this.entityType.namespace;
          const entityId = this.id;

          let entityCallStack = context.entityCallStack;

          if (namespace && entityCallStack.hasOwnProperty(namespace) && entityCallStack[namespace]) {
            entityCallStack = entityCallStack[namespace];
          }

          const hash = entityId + '_' + strHash(JSON.stringify(options.select) + JSON.stringify(options.expandEntity));
          entityCallStack[hash] = this;

          this._options = options;
        }

        await this._resolveEntityCollections(context, propertyKeys, options);

        await this.calculate(context, options);

      } else {
        
        this._filterAdapterMetadata(data, propertyKeys);

        await this._fromLocalPojo(data, propertyKeys);
      }


    }
  }

  private async _resolveEntityCollections(context: ExecutionContext, propertyKeys: Array<string>, options?: IFromPojoOptions) {
    const self = this;
    for (let i = 0; i < propertyKeys.length; i++) {
      const propertyKey = propertyKeys[i];
      const property = self.propertyBag.properties[propertyKey];
      if (property.isEntityCollectionReference()) {
        const ref = property.getValue(null);
        if (ref && ref.resolve) {

          const queryOptions: IPrivateQueryOptions = {
            query: {
              attribute: ref.relatedAttribute,
              operator: '=',
              value: ref.id
            }
          };
          let foundExpands;
          const expandOption = options.expandCollection || options.expandEntity;
          if (expandOption && (foundExpands = expandOption.filter((expand) => propertyKey === expand.attribute)) && foundExpands.length === 1) {
            const expand = foundExpands[0];
            if (expand.childAttributes && expand.childAttributes.length > 0) {
              queryOptions.select = expand.childAttributes.map((child) => child.attribute);
            }
            queryOptions.expandCollection = expand.childAttributes;
          }

          const entityType = await self.datastoreService.getEntityType(ref.relatedType);

          const coll = await entityType.query(context, queryOptions);

          self.propertyBag.setProperty(self, propertyKey, coll);

        }
      }
    }
  }

  public async calculate(context: ExecutionContext, options?: IFromPojoOptions): Promise<void> {
    const select = options && options.select ? options.select : undefined;

    let propertyKeys = this.propertyBag.propertyKeys;

    if (select) {
      propertyKeys = this._filterPropertyKeysBySelect(propertyKeys, select);
    }

    const topSortEdges = [];
    for (let propertyKey in propertyKeys) {
      const property =  this.propertyBag.properties[propertyKeys[propertyKey]];
      if (property.schema && property.schema.calculated) {
        if (property.schema.expandEntity) {
          property.schema.expandEntity.forEach((expand) => {
            topSortEdges.push([propertyKeys[propertyKey], expand.attribute]);
          });
        } else {
          topSortEdges.push([propertyKeys[propertyKey], 'root']);
        }
      }
    }

    const topSortResult = toposort(topSortEdges).reverse().filter((edge) => edge !== 'root');

    for (let propertyKey in topSortResult) {
      const property =  this.propertyBag.properties[topSortResult[propertyKey]];
      if (property.schema && property.schema.calculated) {
        await property.getValueLazy(this, context);
      }
    }
  }

  private _isResolvablelEntity(value: any): boolean {
    return (value instanceof EntityReference || value instanceof Entity);
  }

  private _filterAdapterMetadata(data: any, propertyKeys: Array<string>) {

    if (propertyKeys.indexOf('_meta') !== -1) {

      propertyKeys.splice(propertyKeys.indexOf('_meta'), 1);

      delete data._meta;
    }
  }

  private async _resolveEntityInstances(data: any, propertyKeys: Array<string>, options?: IFromPojoOptions): Promise<void> {

    const resolvePromises = propertyKeys.map(async (propertyKey) => {

      const propertyValue = data[propertyKey];
      const propertySchema = this.schema.attributes ? this.schema.attributes[propertyKey] : undefined;

      if (propertySchema && propertySchema.isComplexType) {

        if (typeof propertyValue === 'undefined' || propertyValue === null || (propertyValue instanceof EntityReference) || (propertyValue instanceof EntityCollectionReference)) {
          return;
        }

        const entityType = await this.datastoreService.getEntityType(<string>propertySchema.type);

        const createEntityOption: IFromPojoOptions = Object.assign({}, options);
        let foundExpands;
        if (createEntityOption.expandEntity && (foundExpands = createEntityOption.expandEntity.filter((expand) => propertyKey === expand.attribute)) && foundExpands.length === 1) {
          const expand = foundExpands[0];
          if (expand.childAttributes && expand.childAttributes.length > 0) {
            createEntityOption.select = expand.childAttributes.map((child) => child.attribute);
          }
          createEntityOption.expandEntity = expand.childAttributes;
        }
        const entity = await entityType.createEntity(this.context, propertyValue, createEntityOption);
        
        data[propertyKey] = entity;
        this.propertyBag.setProperty(this, propertyKey, entity);
      }
    });

    await Promise.all(resolvePromises);
  }

  private async _resolveEntityReferences(data: any, propertyKeys: Array<string>): Promise<void> {

    const resolvePromises = propertyKeys.map(async (propertyKey) => {

      const propertyValue = data[propertyKey];
      const propertySchema = this.schema.attributes ? this.schema.attributes[propertyKey] : undefined;

      const valueType = typeof propertyValue;

      if (valueType === 'undefined' || propertyValue === null) {
        return;
      }

      if (propertySchema && propertySchema.isComplexType) {

        if (propertySchema.isList) {


          const collectionReference = new EntityCollectionReference(this.schema.namespace, <string>propertySchema.type, propertyValue.id, <string>propertySchema.type, propertySchema.relatedAttribute, propertyValue.resolve);
          data[propertyKey] = collectionReference;

        } else if (valueType === 'string') {
          const entityReference = new EntityReference(this.schema.namespace, <string>propertySchema.type, propertyValue);

          data[propertyKey] = entityReference;
        } else {
          if (typeof propertyValue === 'object' && propertyValue._meta && propertyValue._meta.isRef && propertyValue.id) {
            const entityReference = new EntityReference(this.schema.namespace, <string>propertySchema.type, propertyValue.id);
            data[propertyKey] = entityReference;
          }
        }
      }
    });

    await Promise.all(resolvePromises);
  }

  private async _fromRemotePojo(data: any, propertyKeys: Array<string>): Promise<void> {
    
    const isAccessAllowedPromises = propertyKeys.map(async (propertyKey) => {

      const isAccessAllowed = await this.propertyBag.isPropertyAccessAllowed(this.derivedClassInstance, propertyKey, 'read');

      if (!isAccessAllowed) {
        delete data[propertyKey];
      }
    });

    await Promise.all(isAccessAllowedPromises);

    await this._decryptData(data);

    this.propertyBag.updateFromRemote(data);
  }

  private async _fromLocalPojo(data: any, propertyKeys: Array<string>): Promise<void> {
    
    // TODO: do we really need to check write access here?
    const isWriteAccessAllowed = await this.propertyBag.isAccessAllowed(this.derivedClassInstance, propertyKeys, 'write');

    if (!isWriteAccessAllowed) {
      throw new Error('access to write properties declined');
    }

    this.propertyBag.updateFromLocal(data, this);
  }

  private async _encryptData(data: any): Promise<void> {

    const keys = Object.keys(data);
    
    const encryptPromises = keys.map(async (propertyKey) => {

      const attributeSchema = this.schema.attributes[propertyKey];
      const value = data[propertyKey];

      if (attributeSchema.isEncrypted) {

        const encryptedValue = await this.encryptionService.encrypt(value);

        data[propertyKey] = encryptedValue;
      }
    });

    await Promise.all(encryptPromises);
  }

  private async _decryptData(data: any): Promise<void> {

    const keys = Object.keys(data);
    
    const decryptPromises = keys.map(async (propertyKey) => {

      const attributeSchema = this.schema.attributes[propertyKey];
      const value = data[propertyKey];

      if (attributeSchema.isEncrypted) {

        const decryptedValue = await this.encryptionService.decrypt(value);

        data[propertyKey] = decryptedValue;
      }
    });

    await Promise.all(decryptPromises);
  }

  public async save(context: ExecutionContext, options?: IPrivateSaveOptions): Promise<IEntity> {
    const reloadAfterSave = options && options.hasOwnProperty('reloadAfterSave') ? options.reloadAfterSave : true;
    const savedEntity = await this.entityType.save(this, context, options);

    if (!reloadAfterSave) {
      this.propertyBag.isNew = false;
    }
    return savedEntity;
  }

  public async remove(context: ExecutionContext, options?: IPrivateRemoveOptions): Promise<void> {
    await this.entityType.remove(this, context, options);
  }

  public getEntityReference(): IEntityReference {
    return new EntityReference(this.schema.namespace, this.entityType.name, this.id);
  }


}
