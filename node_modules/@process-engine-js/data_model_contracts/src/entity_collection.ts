import { ExecutionContext, IEntity, IToPojoOptions, IPrivateQueryOptions, SaveMode, IFromPojoOptions } from '@process-engine-js/core_contracts';
import { IEntityType } from './interfaces';

export class EntityCollection {

  private _data: Array<IEntity> = [];
  public count: number = 0;
  public offset: number = 0;
  public limit: number = null;
  private _options: IPrivateQueryOptions = undefined;
  private _entityType: IEntityType<IEntity> = undefined;

  constructor(entityType: IEntityType<IEntity>, entityDataSets?: Array<any>, count?: number, offset?: number, limit?: number, options?: IPrivateQueryOptions) {
    this._entityType = entityType;
    if (entityDataSets) {
      entityDataSets.forEach((entityDataSet) => {
        this._data.push(entityDataSet);
      });
      this.count = (count !== undefined) ? count : this._data.length;
      this.offset = offset || 0;
      this.limit = limit || null;
      this._options = {...options};
    }
  }

  public get data(): Array<IEntity> {
    return this._data;
  }

  public get length(): number {
      return this.count;
  }


  public async toPojos(context: ExecutionContext, options?: IToPojoOptions): Promise<any> {

    let toPojoResults = [];
    
    if (this.length > 0) {
      const toPojoResultPromises = this.data.map(async (entity) => {
        const pojo = await entity.toPojo(context, options);
        return pojo;
      });

      toPojoResults = await Promise.all(toPojoResultPromises);
    }
  
    const result = {
      count: this.count,
      offset: this.offset,
      limit: this.limit,
      data: toPojoResults
    };

    return result;
  }


  public async each(context: ExecutionContext, callback: Function): Promise<void> {

    for (let i = 0; i < this.count; i++) {

      if ((i < this.offset) || (i > (this.offset + this.limit - 1))) {
        const offset = i;
        const limit = 10;
        await this._loadMore(context, offset, limit);
      }
      const entity = this._data[i];
      await callback(entity, i);
    }
    
  }

  public add(entity: IEntity, distinct?: boolean):EntityCollection {
    if (!entity || typeof entity !== 'object') {
      throw new Error(`the entity to be added must be a valid object`);
    }

    let doAdd = true;
    if (distinct) {
      const foundEntities = this._data.filter((entityToAdd) => entityToAdd.id === entity.id);
      if (foundEntities.length > 0) {
        doAdd = false;
      }
    }

    if (doAdd) {
      this._data.push(entity);
      this.count++;
      this.limit++;
    }

    return this;
  }

  public async addCollection(context: ExecutionContext, entityCollection: EntityCollection, distinct?: boolean):Promise<EntityCollection> {
    return this._addCollection(context, entityCollection, distinct);
  }

  public async addCollectionDistinct(context: ExecutionContext, entityCollection: EntityCollection):Promise<EntityCollection> {
    return this._addCollection(context, entityCollection, true);
  }

  private async _addCollection(context: ExecutionContext, entityCollection: EntityCollection, distinct?: boolean):Promise<EntityCollection> {
    if (!entityCollection || typeof entityCollection !== 'object' || !entityCollection.data) {
      throw new Error(`the entity collection to be added must be a valid collection containing data`);
    }

    await entityCollection.each(context, async (entity) => {
      this.add(entity, distinct);
    });

    return this;
  }

  private async _loadMore(context: ExecutionContext, offset: number, limit: number): Promise<void> {
    const options = {...this._options};
    options.offset = offset;
    options.limit = limit;

    const result = await this._entityType.dataSource.query(options);

    if (result && result.entities) {

      const fromPojoOptions: IFromPojoOptions = {
        mode: SaveMode.persistance,
        select: options.select,
        expandEntity: options.expandEntity,
        expandCollection: options.expandCollection
      };

      for (let i = 0; i < result.entities.length; i++) {

        const pojo = result.entities[i];

        const entity = await this._entityType.createEntity(context);

        await entity.fromPojo(context, pojo, fromPojoOptions);

        const pos = offset < this.offset ? 0 : offset;
        this.data.splice(pos + i, 0, entity);
      }
    }

    if (this.offset > offset) {
      this.offset = offset;
    }

    if ((this.offset + this.limit) < (offset + limit)) {
      this.limit = (offset + limit - this.offset);
    }
  }
}
