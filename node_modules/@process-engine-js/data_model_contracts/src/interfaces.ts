import * as BluebirdPromise from 'bluebird';

import {EntityCollection} from './entity_collection';
import {IToPojoOptions, ISchemaAttribute, ExecutionContext, IEntity, ISchema, IInheritedSchema, IAllSchemas, IPublicGetOptions, IPublicSaveOptions, IPublicRemoveOptions, IGetSchemasOptions, IPrivateGetOptions, IPrivateSaveOptions, IPrivateRemoveOptions, IPrivateQueryOptions, IFromPojoOptions, IExpand} from '@process-engine-js/core_contracts';

export enum ExpandType {
  Entity,
  Collection
}

export interface IDataSourceConfig {
  adapter: IDataSourceAdapterConfig;
  origin: string;
}

export interface IDataSourceAdapterConfig {
  name: string;
  server: {
    host: string;
    port: number;
    database: string;
    user: string;
    password: string;
  }
}

export interface IEncryptionService {
  encrypt(value: any): Promise<string>;
  decrypt(value: string): Promise<any>;
}

export interface IDatastoreService {
  config: any;
  initialize(): Promise<void>;
  getEntityTypeKeys(options?: IGetEntityTypeKeysOptions): Array<string>;
  getEntityType<T extends IEntity>(typeName: string): Promise<IEntityType<T>>;
  getEntityTypeService(typeName: string): Promise<any>;
  getCatalog(context: ExecutionContext): any;
  getCollection<T extends IEntity>(typeName: string, context: ExecutionContext, options?: IPublicGetOptions): Promise<EntityCollection>;
  getById<T extends IEntity>(typeName: string, id: string, context: ExecutionContext, options?: IPublicGetOptions): Promise<T>;
  updateEntity<T extends IEntity>(typeName: string, id: string, data: any, context: ExecutionContext, options?: IPublicSaveOptions): Promise<T>;
  saveNewEntity<T extends IEntity>(typeName: string, data: any, context: ExecutionContext, options?: IPublicSaveOptions): Promise<T>;
  executeEntityMethod(typeName: string, id: string, method: string, data: any, context: ExecutionContext, options?: IPublicGetOptions): Promise<any>;
  executeEntityTypeMethod(typeName: string, method: string, data: any, context: ExecutionContext, options?: IPublicGetOptions): Promise<any>;
  removeEntity<T extends IEntity>(typeName: string, id: string, context: ExecutionContext, options?: IPublicRemoveOptions): Promise<void>;
}

export interface IConfigService {
  extractDataSourceConfig(config: any, entityKey: string, namespace?: string): IDataSourceConfig;
}

export interface IDataModel {
  getEntityTypeKeys(options?: any): Array<string>;
  getEntityType<T extends IEntity>(namespace: string, typeName: string, additionalEntityTypeConfig?: any): Promise<IEntityType<T>>;
  getEntityTypeService(namespace: string, typeName: string, additionalEntityTypeServiceConfig?: any): Promise<any>;
}

export interface IGetEntityTypeKeysOptions {
  topSort?: boolean;
  namespace?: string;
}

export interface IEntityType<T extends IEntity> {
  name: string;
  origin: string;
  namespace: string;
  dataSource: IDataSource<T>;
  query(context: ExecutionContext, options?: IPrivateQueryOptions): Promise<EntityCollection>;
  save(data: T, context: ExecutionContext, options?: IPrivateSaveOptions): Promise<T>;
  remove(data: T, context: ExecutionContext, options?: IPrivateRemoveOptions): Promise<boolean>;
  getById(id: string, context: ExecutionContext, options?: IPrivateGetOptions): Promise<T>;
  load(entity: T, context: ExecutionContext, options?: IPrivateGetOptions): Promise<void>;
  checkConnection(): Promise<boolean>;
  migrate(schema: any, className: string): Promise<void>;
  initialize(): Promise<void>;
  findOne(context: ExecutionContext, options?: IPrivateQueryOptions): Promise<T>;
  all(context: ExecutionContext, options?: IPrivateQueryOptions): Promise<EntityCollection>;
  count(context: ExecutionContext, options?: IPrivateQueryOptions): Promise<number>;
  createEntity<T extends IEntity>(context: ExecutionContext, data?: any, options?: IFromPojoOptions): Promise<T>;
  getDefaultExpandOptions(expandType: ExpandType): Array<IExpand>;
  createEntityCollection(context: ExecutionContext, data?: Array<any>, options?: IPrivateQueryOptions): Promise<EntityCollection>;
}

export interface IDataSource<T extends IEntity> {
  saveFullEntity: boolean;
  fullSchemaMode: boolean;
  query(options?: IPrivateQueryOptions): Promise<any>;
  save(id: string, data: T, options?: IPrivateSaveOptions): Promise<boolean>;
  remove(id: string, options?: IPrivateRemoveOptions): Promise<boolean>;
  getById(id: string, options?: IPrivateGetOptions): Promise<T>;
  checkConnection(): Promise<boolean>;
  migrate(schema: any, className: string): Promise<void>;
  initialize(): void;
}

export interface IEntityTypes {
  [key: string]: IEntityType<IEntity>;
}

export interface IDatasourceAdapter {
  saveFullEntity: boolean;
  fullSchemaMode: boolean;
  config: IDataSourceAdapterConfig;
  query(dataClassName: string, options?: IPrivateQueryOptions): Promise<any>;
  save(dataClassName: string, id: string, data: any, options?: IPrivateSaveOptions): Promise<any>;
  remove(dataClassName: string, id: string, data: any, options?: IPrivateRemoveOptions): Promise<boolean>;
  getById(dataClassName: string, id: string, options?: IPrivateGetOptions): Promise<any>;
  checkConnection(): Promise<boolean>;
  migrate(schema: any, className: string): Promise<void>;
  initialize(): void;
}

export interface ISchemaProvider {
  getKeys(namespace?: string): Array<string>;

  getAllSchemas(namespace?: string, options?: IGetSchemasOptions): IAllSchemas;
  getOwnSchemasRecursivelyBaseFirst(entityKey: string, namespace?: string, options?: IGetSchemasOptions, currentSchemas?: Array<ISchema>): Array<ISchema>;
  getOwnSchemaRecursively(entityKey: string, namespace?: string, options?: IGetSchemasOptions): IInheritedSchema;
  getOwnSchema(key: string, namespace?: string): ISchema;  
  
  getParentEntityKey(namespace: string, entityKey: string): string;
  findType(type: string): string;
  register(key: string, schema: any, namespace?: string): void;
  initialize(): void;
}

export interface IProperties {
  [property: string]: IProperty;
}

export interface IProperty {
  initializeValue(): Promise<void>;
  getValue(valueSource: any): any;
  getValueLazy(valueSource: any, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any>;
  setValue(valueTarget: any, value: any): void;
  updateFromRemote(remoteValue: any): void;
  isDirty(): boolean;
  isEntityReference(): boolean;
  isEntityCollectionReference(): boolean;
  schema: ISchemaAttribute;
}

export interface ICalculatedProperty extends IProperty {
  setValueLazy(valueTarget: any, value: any, context: ExecutionContext): Promise<void>;
}

export interface IPropertyBag {
  propertyKeys: Array<string>;
  dirtyPropertyKeys: Array<string>;
  properties: IProperties;
  isNew: boolean;
  isDirty(): boolean;
  initialize(): Promise<void>;
  getProperty(propertyThisContext: any, propertyName: string): any;
  getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any>;
  setProperty(propertyThisContext: any, propertyName: string, value: any): void;
  getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any>;
  setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void>;
  createProperty(schema: ISchemaAttribute, propertyName: string, onInitCallback: Function): void
  createCalculatedProperty(schema: ISchemaAttribute, propertyName: string, getCallback: Function, setCallback: Function);
  updateFromLocal(data: any, propertyThisContext: any): void;
  updateFromRemote(data: any): void;
  toPojo(propertyThisContext: any, context: ExecutionContext, options?: IToPojoOptions, propertyKeys?: Array<string>): Promise<any>;
  isAccessAllowed(propertyThisContext: any, propertyKeys: Array<string>, claimActionFragment: string): Promise<boolean>;
  isPropertyAccessAllowed(propertyThisContext: any, propertyName: string, claimActionFragment: string): Promise<boolean>;
  // onPropertyChanged(propertyName: string, propertyChangedCallback: Function): void;
  // notifyPropertyChanged(propertyName: string): void;
}
