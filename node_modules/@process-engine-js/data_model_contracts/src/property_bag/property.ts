import {IProperty, IDatastoreService, ExpandType} from './../interfaces';
import {EntityReference} from './../entity_reference';
import { EntityCollectionReference } from './../entity_collection_reference';
import { EntityCollection } from './../entity_collection';
import {
  ISchemaAttribute, IFactory, ExecutionContext, IPrivateQueryOptions,
  IPrivateGetOptions
} from '@process-engine-js/core_contracts';

import * as copy from 'deepcopy';
import * as deepEqual from 'deep-equal';
import * as strHash from 'string-hash';

export class Property implements IProperty {

  private _schema: ISchemaAttribute = undefined;
  private _datastoreServiceFactory: IFactory<IDatastoreService> = undefined;
  private _datastoreService: IDatastoreService = undefined;
  private _context: ExecutionContext = undefined;
  private _onInitCallback: Function = undefined;
  private _remoteValue: any = undefined;
  private _value: any = undefined;

  constructor(schema: ISchemaAttribute, datastoreServiceFactory: IFactory<IDatastoreService>, context: ExecutionContext, onInitCallback: Function) {
    this._schema = schema;
    this._datastoreServiceFactory = datastoreServiceFactory;
    this._context = context;
    this._onInitCallback = onInitCallback;
  }

  public get schema(): ISchemaAttribute {
    return this._schema;
  }

  private get datastoreService(): IDatastoreService {
    if (!this._datastoreService) {
      this._datastoreService = this._datastoreServiceFactory();
    }
    return this._datastoreService;
  }

  private get context(): ExecutionContext {
    return this._context;
  }

  private get onInitCallback(): Function {
    return this._onInitCallback;
  }

  private get remoteValue(): any {
    return this._remoteValue;
  }

  private set remoteValue(value: any) {
    this._remoteValue = value;
  }

  private get value(): any {
    return this._value;
  }

  private set value(value: any) {
    this._value = value;
  }

  public isDirty(): boolean {
    // comparison can be made strict (===) by passing options with strict: true
    return !deepEqual(this.value, this.remoteValue);
  }

  public isEntityReference(): boolean {
    return this._isEntityReference(this.value);
  }

  public isEntityCollectionReference(): boolean {
    return this._isEntityCollectionReference(this.value);
  }

  public async initializeValue(): Promise<void> {

    if (this.onInitCallback) {
    
      const initialValue = await this.onInitCallback();

      this.value = initialValue;
    }
  }

  public getValue(valueSource: any): any {
    return this._getCurrentValue();
  }

  public async getValueLazy(valueSource: any, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any> {

    const currentValue = this._getCurrentValue();

    const isEntityReference = this._isEntityReference(currentValue);
    const isEntityCollectionReference = this._isEntityCollectionReference(currentValue);

    if (isEntityCollectionReference || currentValue instanceof EntityCollection) {
      if (!isEntityCollectionReference) {
        return currentValue;
      } else {

        const baseQuery = {
          attribute: currentValue.relatedAttribute,
          operator: '=',
          value: currentValue.id
        };

        const queryOptions = (options || {});

        //Compine a possible incoming query with baseQuery (relation)
        if (queryOptions.query) {
          queryOptions.query = {
            operator: 'and',
            queries: [
              queryOptions.query,
              baseQuery
            ]
          }
        } else {
          queryOptions.query = baseQuery;
        }

        const coll = await this._getEntityCollectionByReference(currentValue.relatedType, context, queryOptions);

        this.remoteValue = this.value;

        this.value = coll;

        return coll;
      }
    } else {

      let entity;
      let entityCallStack = context && context.entityCallStack ? context.entityCallStack : null;
      let options;

      if (currentValue) {
        if (isEntityReference) {

          const entityType = await this.datastoreService.getEntityType(currentValue.type);
          options = {};
          options.expandEntity = entityType.getDefaultExpandOptions(ExpandType.Entity);
        } else {
          options = currentValue._options || {};
        }

        const id = currentValue.id;
        const hash = id + '_' + strHash(JSON.stringify(options.select) + JSON.stringify(options.expandEntity));
        let cachedEntity;

        if (entityCallStack) {
          const namespace = currentValue.namespace;

          if (namespace && entityCallStack.hasOwnProperty(namespace) && entityCallStack[namespace]) {
            entityCallStack = entityCallStack[namespace];
          }

          // Caching level for entities resolved within the same context
          if (entityCallStack.hasOwnProperty(hash)) {
            cachedEntity = entityCallStack[hash];
          }

        }

        if (!isEntityReference) {

          if (cachedEntity) {
            return cachedEntity;
          }
          return currentValue;

        } else {

          if (cachedEntity) {
            entity = cachedEntity;
          } else {
            entity = await this._getEntityByReference(currentValue, context, <IPrivateGetOptions> options);
          }
        }
      } else {
        //value has never been fetched - as Entity nor EntityReference
        entity = null;
      }

      this.remoteValue = this.value;

      this.value = entity;

      return entity;
    }
 
  }

  public setValue(valueTarget: any, value: any): void {
    this._value = value;
  }

  public updateFromRemote(remoteValue: any): void {
    this._remoteValue = remoteValue;
    this._value = copy(remoteValue);
  }

  private _getCurrentValue(): any {
    return this.value === undefined ? this.remoteValue : this.value;
  }

  private _isEntityReference(value: any): boolean {
    return value instanceof EntityReference;
  }

  private _isEntityCollectionReference(value: any): boolean {
    return value instanceof EntityCollectionReference;
  }

  private async _getEntityByReference(value: any, context: ExecutionContext, options?: IPrivateGetOptions): Promise<any> {

    const entityReference = <EntityReference>value;
    
    const entityType = await this.datastoreService.getEntityType(entityReference.type);

    const entity = await entityType.getById(entityReference.id, context, options);

    return entity;
  }

  private async _getEntityCollectionByReference(entityCollectionTypeKey: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any> {

    const entityCollectionType = await this.datastoreService.getEntityType(entityCollectionTypeKey);

    const coll = await entityCollectionType.query(context, options);

    return coll;
  }
}
