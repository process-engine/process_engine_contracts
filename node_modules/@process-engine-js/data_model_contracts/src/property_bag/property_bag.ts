import {IDatastoreService, IPropertyBag, IProperty, ICalculatedProperty, IProperties} from './../interfaces';
import {Property} from './property';
import {CalculatedProperty} from './calculated_property';
import {EntityCollection} from '../entity_collection';
import {
  IToPojoOptions, ISchemaAttribute, IFactory, ExecutionContext, IIamService,
  IPrivateQueryOptions, SaveMode
} from '@process-engine-js/core_contracts';
import {IMetadataProvider, MetadataType} from '@process-engine-js/metadata_contracts';

import * as BluebirdPromise from 'bluebird';

interface IPropertyChangedCallbacks {
  [property: string]: IPropertyChangedCallback[];
}

interface IPropertyChangedCallback {
  (property: string, value: any): void;
}

export class PropertyBag implements IPropertyBag {

  private _datastoreServiceFactory: IFactory<IDatastoreService> = undefined;
  private _metadataProvider: IMetadataProvider = undefined;
  private _iamService: IIamService = undefined;
  private _context: ExecutionContext = undefined;
  private _properties: IProperties = {};
  private _propertyChangedCallbacks: IPropertyChangedCallbacks = {};
  public isNew: boolean = true;

  constructor(datastoreServiceFactory: IFactory<IDatastoreService>, metadataProvider: IMetadataProvider, iamService: IIamService, context: ExecutionContext) {
    this._datastoreServiceFactory = datastoreServiceFactory;
    this._metadataProvider = metadataProvider;
    this._iamService = iamService;
    this._context = context;
  }

  private get datastoreServiceFactory(): IFactory<IDatastoreService> {
    return this._datastoreServiceFactory;
  }

  private get metadataProvider(): IMetadataProvider {
    return this._metadataProvider;
  }

  private get iamService(): IIamService {
    return this._iamService;
  }

  private get context(): ExecutionContext {
    return this._context;
  }

  public get properties(): IProperties {
    return this._properties;
  }

  private get propertyChangedCallbacks(): IPropertyChangedCallbacks {
    return this._propertyChangedCallbacks;
  }

  public get propertyKeys(): Array<string> {
    return Object.keys(this.properties);
  }

  public get dirtyPropertyKeys(): Array<string> {

    return this.propertyKeys.filter((propertyKey) => {
      
      const property = this._getProperty(propertyKey);

      return property.isDirty();
    });
  }

  public async initialize(): Promise<void> {

    const initializeValuePromises = this.propertyKeys.map(async (propertyKey: string) => {

      const property = this._getProperty(propertyKey);

      await property.initializeValue();
    });

    await Promise.all(initializeValuePromises);
  }

  public async toPojo(propertyThisContext: any, context: ExecutionContext, options?: IToPojoOptions, propertyKeys?: Array<string>): Promise<any> {

    const propertyKeysToExport = propertyKeys || this.propertyKeys;

    const result = {};
    const bag = this;

    async function exportProperty(propertyKey): Promise<any> {
      const property = bag._getProperty(propertyKey);

      if (property !== undefined) {
        const isEntityReference = property.isEntityReference();
        const isEntityCollectionReference = property.isEntityCollectionReference();

        const isComplexType = property.schema.isComplexType;
        const isCalculated = !!property.schema.calculated;
        let value;
        if (isCalculated) {
          if (options && options.skipCalculation) {
            value = bag.getProperty(propertyThisContext, propertyKey);
          } else {
            value = await bag.getCalculatedProperty(propertyThisContext, propertyKey, context);
          }
        } else {
          value = bag.getProperty(propertyThisContext, propertyKey);
        }

        if (isComplexType) {
          if ((isEntityCollectionReference || value instanceof EntityCollection) && value !== null && value !== undefined) {
            if (!isEntityCollectionReference) {
              let relPojoOptions: IToPojoOptions = {...options};
              relPojoOptions._currentDepth = relPojoOptions._currentDepth + 1;
              if (options && options.mode && options.mode === SaveMode.persistance) {
                relPojoOptions = {
                  _currentDepth: relPojoOptions._currentDepth,
                  maxDepth: relPojoOptions.maxDepth
                };
              }
              return result[propertyKey] = await value.toPojos(context, relPojoOptions);

            }
            return result[propertyKey] = value.toPojo();
          }

          if (!isEntityReference && value !== null && value !== undefined) {
            // if property is complex type and not an entity reference and not null, it must be the resolved entity
            let relPojoOptions: IToPojoOptions = { ...options };
            relPojoOptions._currentDepth = relPojoOptions._currentDepth + 1;
            if (options && options.mode && options.mode === SaveMode.persistance) {
              relPojoOptions = {
                _currentDepth: relPojoOptions._currentDepth,
                maxDepth: relPojoOptions.maxDepth
              };
            }
            return value.toPojo(context, relPojoOptions)
              .then((pojo) => {
                result[propertyKey] = pojo;
              });

          } else if (isEntityReference && value !== null && value !== undefined) {
            // value is an entity reference, simply return the object
            return result[propertyKey] = value.toPojo();
          }
        }
        return result[propertyKey] = value;
      }
    }

    const promises = propertyKeysToExport.map((propertyKey) => exportProperty(propertyKey));
    return BluebirdPromise.all(promises)
    .then(() => result);
  
  }

  public isDirty(): boolean {

    const isDirty = this.propertyKeys.some((propertyKey) => {

      const property = this._getProperty(propertyKey);

      return property.isDirty();
    });

    return isDirty;
  }

  private _getProperty(propertyName: string): IProperty | ICalculatedProperty {
    return this.properties[propertyName];
  }

  private _setProperty(propertyName: string, property: IProperty): void {
    this.properties[propertyName] = property;
  }

  public getProperty(propertyThisContext: any, propertyName: string): any {
  
    const property = this._getProperty(propertyName);

    const value = property.getValue(propertyThisContext);

    return value;
  }

  public async getPropertyLazy(propertyThisContext: any, propertyName: string, context: ExecutionContext, options?: IPrivateQueryOptions): Promise<any> {

    const property = this._getProperty(propertyName);

    const value = await property.getValueLazy(propertyThisContext, context, options);

    return value;
  }

  public setProperty(propertyThisContext: any, propertyName: string, value: any): void {
  
    const property = this._getProperty(propertyName);

    property.setValue(propertyThisContext, value);

    // if (property.isDirty) {
    //   this.notifyPropertyChanged(propertyName);
    // }
  }

  public async getCalculatedProperty(propertyThisContext: any, propertyName: string, context: ExecutionContext): Promise<any> {

    const property = <ICalculatedProperty> this._getProperty(propertyName);

    const value = await property.getValueLazy(propertyThisContext, context);

    return value;
  }

  public async setCalculatedProperty(propertyThisContext: any, propertyName: string, value: any, context: ExecutionContext): Promise<void> {

    const property = <ICalculatedProperty> this._getProperty(propertyName);

    property.setValueLazy(propertyThisContext, value, context);

    // if (property.isDirty) {
    //   this.notifyPropertyChanged(propertyName);
    // }
  }

  public createProperty(schema: ISchemaAttribute, propertyName: string, onInitCallback: Function): void {

    const property = new Property(schema, this.datastoreServiceFactory, this.context, onInitCallback);

    this._setProperty(propertyName, property);
  }

  public createCalculatedProperty(schema: ISchemaAttribute, propertyName: string, getCallback: Function, setCallback: Function): void {

    let property = this._getProperty(propertyName);

    if (property) {
      throw new Error(`property for name ${propertyName} is already declared.`)
    }

    property = new CalculatedProperty(schema, this.datastoreServiceFactory, this.context, propertyName, getCallback, setCallback);
    
    this._setProperty(propertyName, property);
  }

  public updateFromLocal(data: any, propertyThisContext: any) {

    this._setPropertyValues(data, false, propertyThisContext);
  }

  public updateFromRemote(data: any) {

    this.isNew = false;

    this._setPropertyValues(data, true);
  }

  // public onPropertyChanged(property: string, propertyChangedCallback: Function): void {

  //   const callbacks = this.propertyChangedCallbacks[property];

  //   if (!callbacks) {

  //     this.propertyChangedCallbacks[property] = [propertyChangedCallback];

  //   } else {

  //     callbacks.push(propertyChangedCallback);
  //   }
  // }

  // public notifyPropertyChanged(property: string): void {

  //   const callbacks = this.propertyChangedCallbacks[property];

  //   if (callbacks) {

  //     callbacks.map((callback) => {

  //       callback(property, this.getProperty(property));
  //     });
  //   } 
  // }

  private _setPropertyValues(data: any, fromRemote: boolean, propertyThisContext?: any): void {

    const propertyKeys = Object.keys(data);

    propertyKeys.map((propertyKey) => {
      
      const property = this._getProperty(propertyKey);

      if (property) {

        const value = data[propertyKey];

        if (fromRemote) {
          property.updateFromRemote(value);
        } else {
          property.setValue(propertyThisContext, value);
        }
      }
      
      // if (property.isDirty) {
      //   this.notifyPropertyChanged(propertyKey);
      // }
    });
  }

  public async isAccessAllowed(propertyThisContext: any, propertyKeys: Array<string>, claimActionFragment: string): Promise<boolean> {

    const declinedProperties = [];

    const isAccessDeclinedPromises = propertyKeys.map(async (propertyKey) => {

      const isAccessAllowed = await this.isPropertyAccessAllowed(propertyThisContext, propertyKey, claimActionFragment);

      if (!isAccessAllowed) {
        declinedProperties.push(propertyKey);
      }
    });

    await Promise.all(isAccessDeclinedPromises);
    
    // if (declinedProperties.length > 0) {
    //   throw new Error(`access to "${claimActionFragment}"" declined on properties: ${...declinedProperties}`);
    // }

    return declinedProperties.length === 0;
  }

  public async isPropertyAccessAllowed(propertyThisContext: any, propertyName: string, claimActionFragment: string): Promise<boolean> {
    
    const typeName = propertyThisContext.constructor.name;
    
    const claim = `${typeName}.${propertyName}.${claimActionFragment}`;
    
    const isAllowed = await this.iamService.hasClaim(this.context, claim);
    
    return isAllowed;
  }	
}