import {ISchemas, ISchema, ISchemaAttributes, IExpand, IIndexes} from '@process-engine-js/core_contracts';
import {ISchemaProvider} from './interfaces';

export class Schema implements ISchema {

  private _name: string = undefined;
  private _entityKey: string = undefined;
  private _schema: ISchema = undefined;
  
  constructor(entityKey: string, schema: ISchema) {
    this._name = entityKey.replace('Entity', '');
    this._entityKey = entityKey;
    this._schema = schema;
  }

  private get schema(): ISchema {
    return this._schema;
  }

  public get name(): string {
    return this._name;
  }

  public get entityKey(): string {
    return this._entityKey;
  }

  public get namespace(): string {
    return this.schema.namespace;
  }

  public get attributes(): ISchemaAttributes {
    return this.schema.attributes || {};
  }

  public get expandEntity(): Array<IExpand> {
    return this.schema.expandEntity;
  }

  public get expandCollection(): Array<IExpand> {
    return this.schema.expandCollection;
  }

  public get indexes(): IIndexes {
    return this.schema.indexes;
  }

  public get isAbstract(): boolean {
    return this.schema.isAbstract;
  }
  
  public findAttribute(path: string) {
        const attributes = this.attributes || null;
        const attr = null;

        const schemaPaths = (attributes) ? Object.keys(attributes) : null;

        if (schemaPaths) {
            for (let i = 0; i < schemaPaths.length; i++) {
                const schemaPath = schemaPaths[i];

                if (schemaPath && path && typeof schemaPath === 'string' && typeof path === 'string') {
                    const schemaPathArr = schemaPath.split('.');
                    const pathArr = path.split('.');

                    const n = (schemaPathArr.length < pathArr.length) ? schemaPathArr.length : pathArr.length;
                    let segment1;
                    let segment2;
                    let result = true;

                    for (let j = 1; j <= n; j++) {
                        segment1 = schemaPathArr[schemaPathArr.length - j];
                        segment2 = pathArr[pathArr.length - j];

                        if (segment1 === '*') {
                            // any wildcard, abort comparison
                            break;
                        }
                        if (segment1 !== segment2 && segment1 !== '*') {
                            // segments are not equal and no wildcard, abort with failure
                            result = false;
                            break;
                        }
                        if ((j === 0) && (schemaPathArr.length !== pathArr.length)) {
                            // not yet aborted with wildcard and length unequal
                            if ((schemaPathArr.length > pathArr.length) && (schemaPathArr[0] === '*')) {
                                // do nothing
                            } else {
                                result = false;
                            }
                        }
                    }

                    if (result) {
                        return attributes[schemaPath];
                    }
                }
            }
        }

        return attr;
  }
}
